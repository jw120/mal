        core_env: created new core environment
         env_new: called with 0 elements and outer 0x0
ht_from_alternating_list: called with 0 elements
          ht_new: called for 0 entries
         env_new: returning 0x7fa723c05860
         env_set: setting atom <function>
          ht_put: called for key atom
         env_set: setting deref <function>
          ht_put: called for key deref
         env_set: setting reset! <function>
          ht_put: called for key reset!
         env_set: setting swap! <function>
          ht_put: called for key swap!
         env_set: setting list? <function>
          ht_put: called for key list?
         env_set: setting nil? <function>
          ht_put: called for key nil?
          ht_new: called for 10 entries
          ht_put: called for key list?
          ht_put: called for key atom
          ht_put: called for key reset!
          ht_put: called for key swap!
          ht_put: called for key nil?
          ht_put: called for key deref
         env_set: setting true? <function>
          ht_put: called for key true?
         env_set: setting false? <function>
          ht_put: called for key false?
         env_set: setting symbol? <function>
          ht_put: called for key symbol?
         env_set: setting keyword? <function>
          ht_put: called for key keyword?
         env_set: setting vector? <function>
          ht_put: called for key vector?
          ht_new: called for 18 entries
          ht_put: called for key list?
          ht_put: called for key symbol?
          ht_put: called for key vector?
          ht_put: called for key keyword?
          ht_put: called for key atom
          ht_put: called for key reset!
          ht_put: called for key true?
          ht_put: called for key deref
          ht_put: called for key nil?
          ht_put: called for key swap!
          ht_put: called for key false?
         env_set: setting sequential? <function>
          ht_put: called for key sequential?
         env_set: setting map? <function>
          ht_put: called for key map?
         env_set: setting atom? <function>
          ht_put: called for key atom?
         env_set: setting number? <function>
          ht_put: called for key number?
         env_set: setting string? <function>
          ht_put: called for key string?
         env_set: setting fn? <function>
          ht_put: called for key fn?
         env_set: setting macro? <function>
          ht_put: called for key macro?
         env_set: setting prn <function>
          ht_put: called for key prn
          ht_new: called for 30 entries
          ht_put: called for key symbol?
          ht_put: called for key sequential?
          ht_put: called for key string?
          ht_put: called for key vector?
          ht_put: called for key reset!
          ht_put: called for key atom?
          ht_put: called for key atom
          ht_put: called for key deref
          ht_put: called for key nil?
          ht_put: called for key map?
          ht_put: called for key false?
          ht_put: called for key number?
          ht_put: called for key macro?
          ht_put: called for key list?
          ht_put: called for key keyword?
          ht_put: called for key true?
          ht_put: called for key swap!
          ht_put: called for key fn?
          ht_put: called for key prn
         env_set: setting pr-str <function>
          ht_put: called for key pr-str
         env_set: setting str <function>
          ht_put: called for key str
         env_set: setting println <function>
          ht_put: called for key println
         env_set: setting = <function>
          ht_put: called for key =
         env_set: setting read-string <function>
          ht_put: called for key read-string
         env_set: setting slurp <function>
          ht_put: called for key slurp
         env_set: setting throw <function>
          ht_put: called for key throw
         env_set: setting symbol <function>
          ht_put: called for key symbol
         env_set: setting keyword <function>
          ht_put: called for key keyword
         env_set: setting apply <function>
          ht_put: called for key apply
         env_set: setting map <function>
          ht_put: called for key map
         env_set: setting readline <function>
          ht_put: called for key readline
         env_set: setting time-ms <function>
          ht_put: called for key time-ms
          ht_new: called for 49 entries
          ht_put: called for key vector?
          ht_put: called for key pr-str
          ht_put: called for key atom?
          ht_put: called for key keyword?
          ht_put: called for key map
          ht_put: called for key string?
          ht_put: called for key readline
          ht_put: called for key str
          ht_put: called for key time-ms
          ht_put: called for key swap!
          ht_put: called for key read-string
          ht_put: called for key symbol
          ht_put: called for key throw
          ht_put: called for key apply
          ht_put: called for key atom
          ht_put: called for key number?
          ht_put: called for key println
          ht_put: called for key map?
          ht_put: called for key fn?
          ht_put: called for key prn
          ht_put: called for key =
          ht_put: called for key list?
          ht_put: called for key symbol?
          ht_put: called for key slurp
          ht_put: called for key reset!
          ht_put: called for key keyword
          ht_put: called for key macro?
          ht_put: called for key deref
          ht_put: called for key sequential?
          ht_put: called for key nil?
          ht_put: called for key false?
          ht_put: called for key true?
         env_set: setting meta <function>
          ht_put: called for key meta
         env_set: setting with-meta <function>
          ht_put: called for key with-meta
         env_set: setting seq <function>
          ht_put: called for key seq
         env_set: setting conj <function>
          ht_put: called for key conj
         env_set: setting + <function>
          ht_put: called for key +
         env_set: setting - <function>
          ht_put: called for key -
         env_set: setting * <function>
          ht_put: called for key *
         env_set: setting / <function>
          ht_put: called for key /
         env_set: setting < <function>
          ht_put: called for key <
         env_set: setting <= <function>
          ht_put: called for key <=
         env_set: setting > <function>
          ht_put: called for key >
         env_set: setting >= <function>
          ht_put: called for key >=
         env_set: setting list <function>
          ht_put: called for key list
         env_set: setting empty? <function>
          ht_put: called for key empty?
         env_set: setting count <function>
          ht_put: called for key count
         env_set: setting cons <function>
          ht_put: called for key cons
         env_set: setting concat <function>
          ht_put: called for key concat
         env_set: setting first <function>
          ht_put: called for key first
         env_set: setting rest <function>
          ht_put: called for key rest
         env_set: setting nth <function>
          ht_put: called for key nth
          ht_new: called for 79 entries
          ht_put: called for key symbol
          ht_put: called for key seq
          ht_put: called for key read-string
          ht_put: called for key atom
          ht_put: called for key *
          ht_put: called for key <=
          ht_put: called for key list
          ht_put: called for key deref
          ht_put: called for key string?
          ht_put: called for key prn
          ht_put: called for key -
          ht_put: called for key vector?
          ht_put: called for key str
          ht_put: called for key first
          ht_put: called for key atom?
          ht_put: called for key >=
          ht_put: called for key sequential?
          ht_put: called for key count
          ht_put: called for key nth
          ht_put: called for key map
          ht_put: called for key number?
          ht_put: called for key pr-str
          ht_put: called for key fn?
          ht_put: called for key keyword
          ht_put: called for key swap!
          ht_put: called for key reset!
          ht_put: called for key conj
          ht_put: called for key map?
          ht_put: called for key <
          ht_put: called for key readline
          ht_put: called for key time-ms
          ht_put: called for key println
          ht_put: called for key /
          ht_put: called for key +
          ht_put: called for key apply
          ht_put: called for key keyword?
          ht_put: called for key concat
          ht_put: called for key macro?
          ht_put: called for key throw
          ht_put: called for key symbol?
          ht_put: called for key nil?
          ht_put: called for key =
          ht_put: called for key list?
          ht_put: called for key true?
          ht_put: called for key >
          ht_put: called for key meta
          ht_put: called for key cons
          ht_put: called for key empty?
          ht_put: called for key with-meta
          ht_put: called for key false?
          ht_put: called for key rest
          ht_put: called for key slurp
         env_set: setting vector <function>
          ht_put: called for key vector
         env_set: setting hash-map <function>
          ht_put: called for key hash-map
         env_set: setting get <function>
          ht_put: called for key get
         env_set: setting contains? <function>
          ht_put: called for key contains?
         env_set: setting keys <function>
          ht_put: called for key keys
         env_set: setting vals <function>
          ht_put: called for key vals
         env_set: setting assoc <function>
          ht_put: called for key assoc
         env_set: setting dissoc <function>
          ht_put: called for key dissoc
        read_str: called on '(def! not  (fn* (a)    (if a false true)))'
        tokenize: called on '(def! not  (fn* (a)    (if a false true)))' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! not  (fn* (a)    (if a false true)))' (offset 1)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' not  (fn* (a)    (if a false true)))' (offset 5)
        tokenize: returning 'not' (length 3)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '  (fn* (a)    (if a false true)))' (offset 9)
        tokenize: returning '(' (length 1)
       read_atom: received token not, length 3
       read_atom: returning sym 'not'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* (a)    (if a false true)))' (offset 12)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (a)    (if a false true)))' (offset 15)
        tokenize: returning '(' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'a)    (if a false true)))' (offset 17)
        tokenize: returning 'a' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')    (if a false true)))' (offset 18)
        tokenize: returning ')' (length 1)
       read_atom: received token a, length 1
       read_atom: returning sym 'a'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '    (if a false true)))' (offset 19)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if a false true)))' (offset 24)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a false true)))' (offset 26)
        tokenize: returning 'a' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' false true)))' (offset 28)
        tokenize: returning 'false' (length 5)
       read_atom: received token a, length 1
       read_atom: returning sym 'a'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' true)))' (offset 34)
        tokenize: returning 'true' (length 4)
       read_atom: received token false, length 5
       read_atom: returning false
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))' (offset 39)
        tokenize: returning ')' (length 1)
       read_atom: received token true, length 4
       read_atom: returning true
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))' (offset 40)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')' (offset 41)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
       read_atom: received token ), length 1
       read_atom: returning sym ')'
            eval: called with (def! not (fn* (a) (if a false true)))
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
     macroexpand: called with (def! not (fn* (a) (if a false true)))
   is_macro_call: called with (def! not (fn* (a) (if a false true)))
       mal_first: called with (def! not (fn* (a) (if a false true)))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c05860
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! not (fn* (a) (if a false true)))
       mal_first: called with (def! not (fn* (a) (if a false true)))
        mal_rest: called with (def! not (fn* (a) (if a false true)))
def_special_form:  (not (fn* (a) (if a false true)))
            eval: called with (fn* (a) (if a false true))
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
     macroexpand: called with (fn* (a) (if a false true))
   is_macro_call: called with (fn* (a) (if a false true))
       mal_first: called with (fn* (a) (if a false true))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c05860
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* (a) (if a false true))
       mal_first: called with (fn* (a) (if a false true))
        mal_rest: called with (fn* (a) (if a false true))
 fn_special_form:  ((a) (if a false true))
 fn_special_form: in fn* closure body is (if a false true)
         env_set: setting not <function>
          ht_put: called for key not
        read_str: called on '(def! load-file  (fn* (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))'
        tokenize: called on '(def! load-file  (fn* (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! load-file  (fn* (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 1)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' load-file  (fn* (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 5)
        tokenize: returning 'load-file' (length 9)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '  (fn* (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 15)
        tokenize: returning '(' (length 1)
       read_atom: received token load-file, length 9
       read_atom: returning sym 'load-file'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 18)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 21)
        tokenize: returning '(' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'f)    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 23)
        tokenize: returning 'f' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 24)
        tokenize: returning ')' (length 1)
       read_atom: received token f, length 1
       read_atom: returning sym 'f'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '    (eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 25)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'eval (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 30)
        tokenize: returning 'eval' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 34)
        tokenize: returning '(' (length 1)
       read_atom: received token eval, length 4
       read_atom: returning sym 'eval'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'read-string    (str "(do " (slurp f) "\nnil) ")))))' (offset 36)
        tokenize: returning 'read-string' (length 11)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '    (str "(do " (slurp f) "\nnil) ")))))' (offset 47)
        tokenize: returning '(' (length 1)
       read_atom: received token read-string, length 11
       read_atom: returning sym 'read-string'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str "(do " (slurp f) "\nnil) ")))))' (offset 52)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "(do " (slurp f) "\nnil) ")))))' (offset 55)
        tokenize: returning '"(do "' (length 6)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (slurp f) "\nnil) ")))))' (offset 62)
        tokenize: returning '(' (length 1)
       read_atom: received token "(do ", length 6
       read_atom: before remove_escapes '(do '
       read_atom: returning str '(do '
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'slurp f) "\nnil) ")))))' (offset 64)
        tokenize: returning 'slurp' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' f) "\nnil) ")))))' (offset 69)
        tokenize: returning 'f' (length 1)
       read_atom: received token slurp, length 5
       read_atom: returning sym 'slurp'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') "\nnil) ")))))' (offset 71)
        tokenize: returning ')' (length 1)
       read_atom: received token f, length 1
       read_atom: returning sym 'f'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "\nnil) ")))))' (offset 72)
        tokenize: returning '"\nnil) "' (length 9)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))' (offset 82)
        tokenize: returning ')' (length 1)
       read_atom: received token "\nnil) ", length 9
       read_atom: before remove_escapes '\nnil) '
       read_atom: returning str '
nil) '
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))' (offset 83)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))' (offset 84)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))' (offset 85)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')' (offset 86)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
       read_atom: received token ), length 1
       read_atom: returning sym ')'
            eval: called with (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
     macroexpand: called with (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
   is_macro_call: called with (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
       mal_first: called with (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c05860
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
       mal_first: called with (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
        mal_rest: called with (def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
def_special_form:  (load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) ")))))
            eval: called with (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
     macroexpand: called with (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
   is_macro_call: called with (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
       mal_first: called with (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c05860
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
       mal_first: called with (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
        mal_rest: called with (fn* (f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
 fn_special_form:  ((f) (eval (read-string (str "(do " (slurp f) "\nnil) "))))
 fn_special_form: in fn* closure body is (eval (read-string (str "(do " (slurp f) "\nnil) ")))
         env_set: setting load-file <function>
          ht_put: called for key load-file
        read_str: called on '(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))'
        tokenize: called on '(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 1)
        tokenize: returning 'defmacro!' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 10)
        tokenize: returning 'cond' (length 4)
       read_atom: received token defmacro!, length 9
       read_atom: returning sym 'defmacro!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 15)
        tokenize: returning '(' (length 1)
       read_atom: received token cond, length 4
       read_atom: returning sym 'cond'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 17)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 20)
        tokenize: returning '(' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 22)
        tokenize: returning '&' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 23)
        tokenize: returning 'xs' (length 2)
       read_atom: received token &, length 1
       read_atom: returning sym '&'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 26)
        tokenize: returning ')' (length 1)
       read_atom: received token xs, length 2
       read_atom: returning sym 'xs'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 27)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 29)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 31)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 33)
        tokenize: returning '>' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 34)
        tokenize: returning '(' (length 1)
       read_atom: received token >, length 1
       read_atom: returning sym '>'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 36)
        tokenize: returning 'count' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 41)
        tokenize: returning 'xs' (length 2)
       read_atom: received token count, length 5
       read_atom: returning sym 'count'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 44)
        tokenize: returning ')' (length 1)
       read_atom: received token xs, length 2
       read_atom: returning sym 'xs'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 45)
        tokenize: returning '0' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 47)
        tokenize: returning ')' (length 1)
       read_atom: received token 0, length 1
       read_atom: returning int 0
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 48)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 50)
        tokenize: returning 'list' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 54)
        tokenize: returning ''' (length 1)
       read_atom: received token list, length 4
       read_atom: returning sym 'list'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 56)
        tokenize: returning 'if' (length 2)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 58)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 60)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 65)
        tokenize: returning 'xs' (length 2)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 68)
        tokenize: returning ')' (length 1)
       read_atom: received token xs, length 2
       read_atom: returning sym 'xs'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 69)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 71)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 73)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 75)
        tokenize: returning '>' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 76)
        tokenize: returning '(' (length 1)
       read_atom: received token >, length 1
       read_atom: returning sym '>'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 78)
        tokenize: returning 'count' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 83)
        tokenize: returning 'xs' (length 2)
       read_atom: received token count, length 5
       read_atom: returning sym 'count'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 86)
        tokenize: returning ')' (length 1)
       read_atom: received token xs, length 2
       read_atom: returning sym 'xs'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 87)
        tokenize: returning '1' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 89)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 90)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 92)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 95)
        tokenize: returning 'xs' (length 2)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 98)
        tokenize: returning '1' (length 1)
       read_atom: received token xs, length 2
       read_atom: returning sym 'xs'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 100)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 101)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 103)
        tokenize: returning 'throw' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))' (offset 108)
        tokenize: returning '"odd number of forms to cond"' (length 29)
       read_atom: received token throw, length 5
       read_atom: returning sym 'throw'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) (cons 'cond (rest (rest xs)))))))' (offset 138)
        tokenize: returning ')' (length 1)
       read_atom: received token "odd number of forms to cond", length 29
       read_atom: before remove_escapes 'odd number of forms to cond'
       read_atom: returning str 'odd number of forms to cond'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (cons 'cond (rest (rest xs)))))))' (offset 139)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (cons 'cond (rest (rest xs)))))))' (offset 140)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'cons 'cond (rest (rest xs)))))))' (offset 142)
        tokenize: returning 'cons' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'cond (rest (rest xs)))))))' (offset 146)
        tokenize: returning ''' (length 1)
       read_atom: received token cons, length 4
       read_atom: returning sym 'cons'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'cond (rest (rest xs)))))))' (offset 148)
        tokenize: returning 'cond' (length 4)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest (rest xs)))))))' (offset 152)
        tokenize: returning '(' (length 1)
       read_atom: received token cond, length 4
       read_atom: returning sym 'cond'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest (rest xs)))))))' (offset 154)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest xs)))))))' (offset 158)
        tokenize: returning '(' (length 1)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest xs)))))))' (offset 160)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' xs)))))))' (offset 164)
        tokenize: returning 'xs' (length 2)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))))' (offset 167)
        tokenize: returning ')' (length 1)
       read_atom: received token xs, length 2
       read_atom: returning sym 'xs'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))' (offset 168)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))' (offset 169)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))' (offset 170)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))' (offset 171)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))' (offset 172)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')' (offset 173)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
       read_atom: received token ), length 1
       read_atom: returning sym ')'
            eval: called with (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "load-file" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
     macroexpand: called with (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
   is_macro_call: called with (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
       mal_first: called with (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
         env_get: getting defmacro!
        env_find: finding defmacro! in 0x7fa723c05860
          ht_has: called for key defmacro!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
       mal_first: called with (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
        mal_rest: called with (defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
defmacro_special_form:  (cond (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))))
            eval: called with (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "load-file" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
     macroexpand: called with (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
   is_macro_call: called with (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
       mal_first: called with (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c05860
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
       mal_first: called with (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
        mal_rest: called with (fn* (& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
 fn_special_form:  ((& xs) (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs))))))
 fn_special_form: in fn* closure body is (if (> (count xs) 0) (list (quote if) (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons (quote cond) (rest (rest xs)))))
         env_set: setting cond <function>
          ht_put: called for key cond
        read_str: called on '(def! *host-language* "jw-c")'
        tokenize: called on '(def! *host-language* "jw-c")' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! *host-language* "jw-c")' (offset 1)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' *host-language* "jw-c")' (offset 5)
        tokenize: returning '*host-language*' (length 15)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "jw-c")' (offset 21)
        tokenize: returning '"jw-c"' (length 6)
       read_atom: received token *host-language*, length 15
       read_atom: returning sym '*host-language*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')' (offset 28)
        tokenize: returning ')' (length 1)
       read_atom: received token "jw-c", length 6
       read_atom: before remove_escapes 'jw-c'
       read_atom: returning str 'jw-c'
       read_form: starting read_atom
       read_atom: top of loop
       read_atom: received token ), length 1
       read_atom: returning sym ')'
            eval: called with (def! *host-language* "jw-c")
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "load-file" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
  "cond" -> <function>
     macroexpand: called with (def! *host-language* "jw-c")
   is_macro_call: called with (def! *host-language* "jw-c")
       mal_first: called with (def! *host-language* "jw-c")
         env_get: getting def!
        env_find: finding def! in 0x7fa723c05860
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! *host-language* "jw-c")
       mal_first: called with (def! *host-language* "jw-c")
        mal_rest: called with (def! *host-language* "jw-c")
def_special_form:  (*host-language* "jw-c")
            eval: called with "jw-c"
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "load-file" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
  "cond" -> <function>
     macroexpand: called with "jw-c"
   is_macro_call: called with "jw-c"
            eval: macro expanded "jw-c"
        eval_ast: called with "jw-c"
         env_set: setting *host-language* "jw-c"
          ht_put: called for key *host-language*
environment: core (outer=NULL)
  "atom?" -> <function>
  "deref" -> <function>
  "read-string" -> <function>
  "cons" -> <function>
  "concat" -> <function>
  "rest" -> <function>
  "string?" -> <function>
  "vals" -> <function>
  "with-meta" -> <function>
  "*" -> <function>
  "symbol" -> <function>
  "swap!" -> <function>
  "throw" -> <function>
  "contains?" -> <function>
  "reset!" -> <function>
  "/" -> <function>
  "list" -> <function>
  "seq" -> <function>
  "keyword" -> <function>
  "prn" -> <function>
  "map?" -> <function>
  "time-ms" -> <function>
  "hash-map" -> <function>
  "true?" -> <function>
  "pr-str" -> <function>
  "+" -> <function>
  "first" -> <function>
  "list?" -> <function>
  "false?" -> <function>
  "readline" -> <function>
  "symbol?" -> <function>
  "empty?" -> <function>
  ">=" -> <function>
  "fn?" -> <function>
  "=" -> <function>
  "nil?" -> <function>
  "keys" -> <function>
  "vector?" -> <function>
  "<=" -> <function>
  "slurp" -> <function>
  "load-file" -> <function>
  "macro?" -> <function>
  "atom" -> <function>
  "str" -> <function>
  "map" -> <function>
  "keyword?" -> <function>
  "not" -> <function>
  "dissoc" -> <function>
  "println" -> <function>
  "count" -> <function>
  "meta" -> <function>
  ">" -> <function>
  "conj" -> <function>
  "number?" -> <function>
  "vector" -> <function>
  "get" -> <function>
  "*host-language*" -> "jw-c"
  "sequential?" -> <function>
  "assoc" -> <function>
  "apply" -> <function>
  "nth" -> <function>
  "<" -> <function>
  "-" -> <function>
  "cond" -> <function>
         env_set: setting eval <function>
          ht_put: called for key eval
         env_new: called with 0 elements and outer 0x7fa723c05860
ht_from_alternating_list: called with 0 elements
          ht_new: called for 0 entries
         env_new: returning 0x7fa723c1c000
         env_set: setting *ARGV* ()
          ht_put: called for key *ARGV*
            main: calling setup_mal_argv
  setup_mal_argv: adding argv with 0 args
  setup_mal_argv: eval args ()
  setup_mal_argv: eval quoted_args (quote ())
  setup_mal_argv: eval (def! *ARGV* (quote ()))
            eval: called with (def! *ARGV* (quote ()))
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (def! *ARGV* (quote ()))
   is_macro_call: called with (def! *ARGV* (quote ()))
       mal_first: called with (def! *ARGV* (quote ()))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! *ARGV* (quote ()))
       mal_first: called with (def! *ARGV* (quote ()))
        mal_rest: called with (def! *ARGV* (quote ()))
def_special_form:  (*ARGV* (quote ()))
            eval: called with (quote ())
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (quote ())
   is_macro_call: called with (quote ())
       mal_first: called with (quote ())
         env_get: getting quote
        env_find: finding quote in 0x7fa723c1c000
          ht_has: called for key quote
          ht_has: called for key quote
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (quote ())
       mal_first: called with (quote ())
        mal_rest: called with (quote ())
         env_set: setting *ARGV* ()
          ht_put: called for key *ARGV*
  setup_mal_argv: eval ret ()
            main: calling load-file
       load_file: loading file ../mal/step8_macros.mal
       load_file: read-eval  (load-file "../mal/step8_macros.mal")
        read_str: called on '(load-file "../mal/step8_macros.mal")'
        tokenize: called on '(load-file "../mal/step8_macros.mal")' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'load-file "../mal/step8_macros.mal")' (offset 1)
        tokenize: returning 'load-file' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "../mal/step8_macros.mal")' (offset 10)
        tokenize: returning '"../mal/step8_macros.mal"' (length 25)
       read_atom: received token load-file, length 9
       read_atom: returning sym 'load-file'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')' (offset 36)
        tokenize: returning ')' (length 1)
       read_atom: received token "../mal/step8_macros.mal", length 25
       read_atom: before remove_escapes '../mal/step8_macros.mal'
       read_atom: returning str '../mal/step8_macros.mal'
       read_form: starting read_atom
       read_atom: top of loop
       read_atom: received token ), length 1
       read_atom: returning sym ')'
            eval: called with (load-file "../mal/step8_macros.mal")
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (load-file "../mal/step8_macros.mal")
   is_macro_call: called with (load-file "../mal/step8_macros.mal")
       mal_first: called with (load-file "../mal/step8_macros.mal")
         env_get: getting load-file
        env_find: finding load-file in 0x7fa723c1c000
          ht_has: called for key load-file
          ht_has: called for key load-file
         env_get: found 0x7fa723c05860
          ht_get: called for key load-file
         env_get: returning load-file <function>
   is_macro_call: returning FALSE
            eval: macro expanded (load-file "../mal/step8_macros.mal")
       mal_first: called with (load-file "../mal/step8_macros.mal")
        mal_rest: called with (load-file "../mal/step8_macros.mal")
        eval_ast: called with (load-file "../mal/step8_macros.mal")
            eval: called with load-file
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with load-file
   is_macro_call: called with load-file
            eval: macro expanded load-file
        eval_ast: called with load-file
         env_get: getting load-file
        env_find: finding load-file in 0x7fa723c1c000
          ht_has: called for key load-file
          ht_has: called for key load-file
         env_get: found 0x7fa723c05860
          ht_get: called for key load-file
         env_get: returning load-file <function>
            eval: called with "../mal/step8_macros.mal"
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with "../mal/step8_macros.mal"
   is_macro_call: called with "../mal/step8_macros.mal"
            eval: macro expanded "../mal/step8_macros.mal"
        eval_ast: called with "../mal/step8_macros.mal"
            eval: after args evaluated have (<function> "../mal/step8_macros.mal")
       mal_first: called with (<function> "../mal/step8_macros.mal")
        mal_rest: called with (<function> "../mal/step8_macros.mal")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("../mal/step8_macros.mal")
        env_new2: called with outer 0x7fa723c05860
   ht_from_lists: called with 1 1 keys
          ht_new: called for 1 entries
   ht_from_lists: in while
          ht_put: called for key f
        env_new2: returning 0x7fa723c1d8b0
            eval: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
   is_macro_call: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
       mal_first: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
         env_get: getting eval
        env_find: finding eval in 0x7fa723c1d8b0
          ht_has: called for key eval
          ht_has: called for key eval
         env_get: found 0x7fa723c05860
          ht_get: called for key eval
         env_get: returning eval <function>
   is_macro_call: returning FALSE
            eval: macro expanded (eval (read-string (str "(do " (slurp f) "\nnil) ")))
       mal_first: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
        mal_rest: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
        eval_ast: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
            eval: called with eval
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with eval
   is_macro_call: called with eval
            eval: macro expanded eval
        eval_ast: called with eval
         env_get: getting eval
        env_find: finding eval in 0x7fa723c1d8b0
          ht_has: called for key eval
          ht_has: called for key eval
         env_get: found 0x7fa723c05860
          ht_get: called for key eval
         env_get: returning eval <function>
            eval: called with (read-string (str "(do " (slurp f) "\nnil) "))
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with (read-string (str "(do " (slurp f) "\nnil) "))
   is_macro_call: called with (read-string (str "(do " (slurp f) "\nnil) "))
       mal_first: called with (read-string (str "(do " (slurp f) "\nnil) "))
         env_get: getting read-string
        env_find: finding read-string in 0x7fa723c1d8b0
          ht_has: called for key read-string
          ht_has: called for key read-string
         env_get: found 0x7fa723c05860
          ht_get: called for key read-string
         env_get: returning read-string <function>
   is_macro_call: returning FALSE
            eval: macro expanded (read-string (str "(do " (slurp f) "\nnil) "))
       mal_first: called with (read-string (str "(do " (slurp f) "\nnil) "))
        mal_rest: called with (read-string (str "(do " (slurp f) "\nnil) "))
        eval_ast: called with (read-string (str "(do " (slurp f) "\nnil) "))
            eval: called with read-string
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with read-string
   is_macro_call: called with read-string
            eval: macro expanded read-string
        eval_ast: called with read-string
         env_get: getting read-string
        env_find: finding read-string in 0x7fa723c1d8b0
          ht_has: called for key read-string
          ht_has: called for key read-string
         env_get: found 0x7fa723c05860
          ht_get: called for key read-string
         env_get: returning read-string <function>
            eval: called with (str "(do " (slurp f) "\nnil) ")
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with (str "(do " (slurp f) "\nnil) ")
   is_macro_call: called with (str "(do " (slurp f) "\nnil) ")
       mal_first: called with (str "(do " (slurp f) "\nnil) ")
         env_get: getting str
        env_find: finding str in 0x7fa723c1d8b0
          ht_has: called for key str
          ht_has: called for key str
         env_get: found 0x7fa723c05860
          ht_get: called for key str
         env_get: returning str <function>
   is_macro_call: returning FALSE
            eval: macro expanded (str "(do " (slurp f) "\nnil) ")
       mal_first: called with (str "(do " (slurp f) "\nnil) ")
        mal_rest: called with (str "(do " (slurp f) "\nnil) ")
        eval_ast: called with (str "(do " (slurp f) "\nnil) ")
            eval: called with str
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with str
   is_macro_call: called with str
            eval: macro expanded str
        eval_ast: called with str
         env_get: getting str
        env_find: finding str in 0x7fa723c1d8b0
          ht_has: called for key str
          ht_has: called for key str
         env_get: found 0x7fa723c05860
          ht_get: called for key str
         env_get: returning str <function>
            eval: called with "(do "
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with "(do "
   is_macro_call: called with "(do "
            eval: macro expanded "(do "
        eval_ast: called with "(do "
            eval: called with (slurp f)
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with (slurp f)
   is_macro_call: called with (slurp f)
       mal_first: called with (slurp f)
         env_get: getting slurp
        env_find: finding slurp in 0x7fa723c1d8b0
          ht_has: called for key slurp
          ht_has: called for key slurp
         env_get: found 0x7fa723c05860
          ht_get: called for key slurp
         env_get: returning slurp <function>
   is_macro_call: returning FALSE
            eval: macro expanded (slurp f)
       mal_first: called with (slurp f)
        mal_rest: called with (slurp f)
        eval_ast: called with (slurp f)
            eval: called with slurp
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with slurp
   is_macro_call: called with slurp
            eval: macro expanded slurp
        eval_ast: called with slurp
         env_get: getting slurp
        env_find: finding slurp in 0x7fa723c1d8b0
          ht_has: called for key slurp
          ht_has: called for key slurp
         env_get: found 0x7fa723c05860
          ht_get: called for key slurp
         env_get: returning slurp <function>
            eval: called with f
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with f
   is_macro_call: called with f
            eval: macro expanded f
        eval_ast: called with f
         env_get: getting f
        env_find: finding f in 0x7fa723c1d8b0
          ht_has: called for key f
         env_get: found 0x7fa723c1d8b0
          ht_get: called for key f
         env_get: returning f "../mal/step8_macros.mal"
            eval: after args evaluated have (<function> "../mal/step8_macros.mal")
       mal_first: called with (<function> "../mal/step8_macros.mal")
        mal_rest: called with (<function> "../mal/step8_macros.mal")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("../mal/step8_macros.mal")
      core_slurp: called with ("../mal/step8_macros.mal")
            eval: called with "\nnil) "
environment: d8b0 (outer=core)
  "f" -> "../mal/step8_macros.mal"
     macroexpand: called with "\nnil) "
   is_macro_call: called with "\nnil) "
            eval: macro expanded "\nnil) "
        eval_ast: called with "\nnil) "
            eval: after args evaluated have (<function> "(do " "(load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n" "\nnil) ")
       mal_first: called with (<function> "(do " "(load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n" "\nnil) ")
        mal_rest: called with (<function> "(do " "(load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n" "\nnil) ")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("(do " "(load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n" "\nnil) ")
        core_str: called with ("(do " "(load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n" "\nnil) ")
            eval: after args evaluated have (<function> "(do (load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n\nnil) ")
       mal_first: called with (<function> "(do (load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n\nnil) ")
        mal_rest: called with (<function> "(do (load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n\nnil) ")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("(do (load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n\nnil) ")
core_read_string: called with ("(do (load-file \"../mal/env.mal\")\n(load-file \"../mal/core.mal\")\n\n;; read\n(def! READ read-string)\n\n\n;; eval\n(def! is-pair (fn* [x]\n  (if (sequential? x)\n    (not (empty? x)))))\n\n(def! QUASIQUOTE (fn* [ast]\n  (if (not (is-pair ast))\n    (list 'quote ast)\n    (let* [a0 (first ast)]\n      (cond\n       (= 'unquote a0)\n       (nth ast 1)\n\n       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`\n       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))\n\n       \"else\"\n       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))\n\n(def! MACROEXPAND (fn* [ast env]\n  (let* [a0 (if (list? ast) (first ast))\n         e  (if (symbol? a0) (env-find env a0))\n         m  (if e (env-get e a0))]\n    (if (_macro? m)\n      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)\n      ast))))\n\n(def! eval-ast (fn* [ast env]\n  ;; (do (prn \"eval-ast\" ast \"/\" (keys env)) )\n  (cond\n    (symbol? ast) (env-get env ast)\n\n    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)\n\n    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))\n\n    (map? ast)    (apply hash-map\n                    (apply concat\n                      (map (fn* [k] [k (EVAL (get ast k) env)])\n                           (keys ast))))\n\n    \"else\"        ast)))\n\n(def! LET (fn* [env binds form]\n  (if (empty? binds)\n    (EVAL form env)\n    (do\n      (env-set env (first binds) (EVAL (nth binds 1) env))\n      (LET env (rest (rest binds)) form)))))\n\n(def! EVAL (fn* [ast env]\n  ;; (do (prn \"EVAL\" ast \"/\" (keys @env)) )\n  (let* [ast (MACROEXPAND ast env)]\n    (if (not (list? ast))\n      (eval-ast ast env)\n\n      ;; apply list\n      (let* [a0 (first ast)]\n        (cond\n          (empty? ast)\n          ast\n\n          (= 'def! a0)\n          (env-set env (nth ast 1) (EVAL (nth ast 2) env))\n\n          (= 'let* a0)\n          (LET (new-env env) (nth ast 1) (nth ast 2))\n\n          (= 'quote a0)\n          (nth ast 1)\n\n          (= 'quasiquote a0)\n          (EVAL (QUASIQUOTE (nth ast 1)) env)\n\n          (= 'defmacro! a0)\n          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__\n                                             (EVAL (nth ast 2) env)))\n\n          (= 'macroexpand a0)\n          (MACROEXPAND (nth ast 1) env)\n\n          (= 'do a0)\n          (let* [el (eval-ast (rest ast) env)]\n            (nth el (- (count el) 1)))\n\n          (= 'if a0)\n          (if (EVAL (nth ast 1) env)\n            (EVAL (nth ast 2) env)\n            (if (> (count ast) 3)\n              (EVAL (nth ast 3) env)))\n\n          (= 'fn* a0)\n          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))\n\n          \"else\"\n          (let* [el (eval-ast ast env)]\n            (apply (first el) (rest el)))))))))\n\n\n;; print\n(def! PRINT pr-str)\n\n;; repl\n(def! repl-env (new-env))\n(def! rep (fn* [strng]\n  (PRINT (EVAL (READ strng) repl-env))))\n\n;; core.mal: defined directly using mal\n(map (fn* [data] (apply env-set repl-env data)) core_ns)\n(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))\n(env-set repl-env '*ARGV* (rest *ARGV*))\n\n;; core.mal: defined using the new language itself\n(rep \"(def! not (fn* [a] (if a false true)))\")\n(rep \"(def! load-file (fn* (f) (eval (read-string (str \\\"(do \\\" (slurp f) \\\"\\nnil)\\\")))))\")\n(rep \"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \\\"odd number of forms to cond\\\")) (cons 'cond (rest (rest xs)))))))\")\n\n;; repl loop\n(def! repl-loop (fn* [line]\n  (if line\n    (do\n      (if (not (= \"\" line))\n        (try*\n          (println (rep line))\n          (catch* exc\n            (println \"Uncaught exception:\" exc))))\n      (repl-loop (readline \"mal-user> \"))))))\n\n;; main\n(if (empty? *ARGV*)\n  (repl-loop \"\")\n  (rep (str \"(load-file \\\"\" (first *ARGV*) \"\\\")\")))\n\nnil) ")
        read_str: called on '(do (load-file "../mal/env.mal")
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) '
        tokenize: called on '(do (load-file "../mal/env.mal")
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'do (load-file "../mal/env.mal")
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1)
        tokenize: returning 'do' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (load-file "../mal/env.mal")
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3)
        tokenize: returning '(' (length 1)
       read_atom: received token do, length 2
       read_atom: returning sym 'do'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'load-file "../mal/env.mal")
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 5)
        tokenize: returning 'load-file' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "../mal/env.mal")
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 14)
        tokenize: returning '"../mal/env.mal"' (length 16)
       read_atom: received token load-file, length 9
       read_atom: returning sym 'load-file'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 31)
        tokenize: returning ')' (length 1)
       read_atom: received token "../mal/env.mal", length 16
       read_atom: before remove_escapes '../mal/env.mal'
       read_atom: returning str '../mal/env.mal'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
(load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 32)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'load-file "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 34)
        tokenize: returning 'load-file' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "../mal/core.mal")

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 43)
        tokenize: returning '"../mal/core.mal"' (length 17)
       read_atom: received token load-file, length 9
       read_atom: returning sym 'load-file'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 61)
        tokenize: returning ')' (length 1)
       read_atom: received token "../mal/core.mal", length 17
       read_atom: before remove_escapes '../mal/core.mal'
       read_atom: returning str '../mal/core.mal'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

;; read
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 62)
        tokenize: returning ';; read' (length 7)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 71)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 73)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' READ read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 77)
        tokenize: returning 'READ' (length 4)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' read-string)


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 82)
        tokenize: returning 'read-string' (length 11)
       read_atom: received token READ, length 4
       read_atom: returning sym 'READ'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 94)
        tokenize: returning ')' (length 1)
       read_atom: received token read-string, length 11
       read_atom: returning sym 'read-string'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '


;; eval
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 95)
        tokenize: returning ';; eval' (length 7)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 105)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 107)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' is-pair (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 111)
        tokenize: returning 'is-pair' (length 7)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 119)
        tokenize: returning '(' (length 1)
       read_atom: received token is-pair, length 7
       read_atom: returning sym 'is-pair'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 121)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 124)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'x]
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 126)
        tokenize: returning 'x' (length 1)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 127)
        tokenize: returning ']' (length 1)
       read_atom: received token x, length 1
       read_atom: returning sym 'x'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 128)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 132)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 134)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'sequential? x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 136)
        tokenize: returning 'sequential?' (length 11)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' x)
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 147)
        tokenize: returning 'x' (length 1)
       read_atom: received token sequential?, length 11
       read_atom: returning sym 'sequential?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 149)
        tokenize: returning ')' (length 1)
       read_atom: received token x, length 1
       read_atom: returning sym 'x'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 150)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'not (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 156)
        tokenize: returning 'not' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 159)
        tokenize: returning '(' (length 1)
       read_atom: received token not, length 3
       read_atom: returning sym 'not'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'empty? x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 161)
        tokenize: returning 'empty?' (length 6)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' x)))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 167)
        tokenize: returning 'x' (length 1)
       read_atom: received token empty?, length 6
       read_atom: returning sym 'empty?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 169)
        tokenize: returning ')' (length 1)
       read_atom: received token x, length 1
       read_atom: returning sym 'x'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 170)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 171)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 172)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 173)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 174)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 177)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' QUASIQUOTE (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 181)
        tokenize: returning 'QUASIQUOTE' (length 10)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 192)
        tokenize: returning '(' (length 1)
       read_atom: received token QUASIQUOTE, length 10
       read_atom: returning sym 'QUASIQUOTE'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 194)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 197)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ast]
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 199)
        tokenize: returning 'ast' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 202)
        tokenize: returning ']' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 203)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 207)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 209)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'not (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 211)
        tokenize: returning 'not' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 214)
        tokenize: returning '(' (length 1)
       read_atom: received token not, length 3
       read_atom: returning sym 'not'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'is-pair ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 216)
        tokenize: returning 'is-pair' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 223)
        tokenize: returning 'ast' (length 3)
       read_atom: received token is-pair, length 7
       read_atom: returning sym 'is-pair'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 227)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 228)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 229)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 235)
        tokenize: returning 'list' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 239)
        tokenize: returning ''' (length 1)
       read_atom: received token list, length 4
       read_atom: returning sym 'list'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'quote ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 241)
        tokenize: returning 'quote' (length 5)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 246)
        tokenize: returning 'ast' (length 3)
       read_atom: received token quote, length 5
       read_atom: returning sym 'quote'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 250)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 251)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 257)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 261)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'a0 (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 263)
        tokenize: returning 'a0' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 265)
        tokenize: returning '(' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 267)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 272)
        tokenize: returning 'ast' (length 3)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 276)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 277)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 278)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'cond
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 286)
        tokenize: returning 'cond' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
       (= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 290)
        tokenize: returning '(' (length 1)
       read_atom: received token cond, length 4
       read_atom: returning sym 'cond'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 299)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 300)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'unquote a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 302)
        tokenize: returning 'unquote' (length 7)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 309)
        tokenize: returning 'a0' (length 2)
       read_atom: received token unquote, length 7
       read_atom: returning sym 'unquote'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 312)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
       (nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 313)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 322)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 325)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1)

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 329)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 331)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

       (if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 332)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 342)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 344)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'is-pair a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 346)
        tokenize: returning 'is-pair' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0) (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 353)
        tokenize: returning 'a0' (length 2)
       read_atom: received token is-pair, length 7
       read_atom: returning sym 'is-pair'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 356)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 357)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 359)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 360)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'splice-unquote (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 362)
        tokenize: returning 'splice-unquote' (length 14)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 376)
        tokenize: returning '(' (length 1)
       read_atom: received token splice-unquote, length 14
       read_atom: returning sym 'splice-unquote'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 378)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 383)
        tokenize: returning 'a0' (length 2)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 386)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 387)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 388)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ; `if` means `and`
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 389)
        tokenize: returning '; `if` means `and`' (length 18)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
       (list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 408)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 417)
        tokenize: returning 'list' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 421)
        tokenize: returning ''' (length 1)
       read_atom: received token list, length 4
       read_atom: returning sym 'list'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'concat (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 423)
        tokenize: returning 'concat' (length 6)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 429)
        tokenize: returning '(' (length 1)
       read_atom: received token concat, length 6
       read_atom: returning sym 'concat'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 431)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 434)
        tokenize: returning 'a0' (length 2)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 437)
        tokenize: returning '1' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 439)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 440)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'QUASIQUOTE (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 442)
        tokenize: returning 'QUASIQUOTE' (length 10)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 452)
        tokenize: returning '(' (length 1)
       read_atom: received token QUASIQUOTE, length 10
       read_atom: returning sym 'QUASIQUOTE'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 454)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 458)
        tokenize: returning 'ast' (length 3)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 462)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 463)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 464)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

       "else"
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 465)
        tokenize: returning '"else"' (length 6)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
       (list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 480)
        tokenize: returning '(' (length 1)
       read_atom: received token "else", length 6
       read_atom: before remove_escapes 'else'
       read_atom: returning str 'else'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 489)
        tokenize: returning 'list' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 493)
        tokenize: returning ''' (length 1)
       read_atom: received token list, length 4
       read_atom: returning sym 'list'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'cons (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 495)
        tokenize: returning 'cons' (length 4)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 499)
        tokenize: returning '(' (length 1)
       read_atom: received token cons, length 4
       read_atom: returning sym 'cons'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'QUASIQUOTE a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 501)
        tokenize: returning 'QUASIQUOTE' (length 10)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0) (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 511)
        tokenize: returning 'a0' (length 2)
       read_atom: received token QUASIQUOTE, length 10
       read_atom: returning sym 'QUASIQUOTE'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 514)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 515)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'QUASIQUOTE (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 517)
        tokenize: returning 'QUASIQUOTE' (length 10)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 527)
        tokenize: returning '(' (length 1)
       read_atom: received token QUASIQUOTE, length 10
       read_atom: returning sym 'QUASIQUOTE'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 529)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 533)
        tokenize: returning 'ast' (length 3)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 537)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 538)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 539)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 540)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 541)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 542)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 543)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 544)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 545)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 548)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' MACROEXPAND (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 552)
        tokenize: returning 'MACROEXPAND' (length 11)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 564)
        tokenize: returning '(' (length 1)
       read_atom: received token MACROEXPAND, length 11
       read_atom: returning sym 'MACROEXPAND'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 566)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 569)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ast env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 571)
        tokenize: returning 'ast' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env]
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 574)
        tokenize: returning 'env' (length 3)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 578)
        tokenize: returning ']' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 579)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 583)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 587)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'a0 (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 589)
        tokenize: returning 'a0' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 591)
        tokenize: returning '(' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 593)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 595)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list? ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 597)
        tokenize: returning 'list?' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast) (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 602)
        tokenize: returning 'ast' (length 3)
       read_atom: received token list?, length 5
       read_atom: returning sym 'list?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 606)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 607)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 609)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 614)
        tokenize: returning 'ast' (length 3)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 618)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 619)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
         e  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 620)
        tokenize: returning 'e' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '  (if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 631)
        tokenize: returning '(' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 634)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 636)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'symbol? a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 638)
        tokenize: returning 'symbol?' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0) (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 645)
        tokenize: returning 'a0' (length 2)
       read_atom: received token symbol?, length 7
       read_atom: returning sym 'symbol?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 648)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 649)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-find env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 651)
        tokenize: returning 'env-find' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 659)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-find, length 8
       read_atom: returning sym 'env-find'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 663)
        tokenize: returning 'a0' (length 2)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 666)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 667)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
         m  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 668)
        tokenize: returning 'm' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '  (if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 679)
        tokenize: returning '(' (length 1)
       read_atom: received token m, length 1
       read_atom: returning sym 'm'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 682)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 684)
        tokenize: returning 'e' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 686)
        tokenize: returning '(' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-get e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 688)
        tokenize: returning 'env-get' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 695)
        tokenize: returning 'e' (length 1)
       read_atom: received token env-get, length 7
       read_atom: returning sym 'env-get'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 697)
        tokenize: returning 'a0' (length 2)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 700)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 701)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 702)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 703)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 709)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 711)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '_macro? m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 713)
        tokenize: returning '_macro?' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' m)
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 720)
        tokenize: returning 'm' (length 1)
       read_atom: received token _macro?, length 7
       read_atom: returning sym '_macro?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 722)
        tokenize: returning ')' (length 1)
       read_atom: received token m, length 1
       read_atom: returning sym 'm'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 723)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 731)
        tokenize: returning 'MACROEXPAND' (length 11)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 742)
        tokenize: returning '(' (length 1)
       read_atom: received token MACROEXPAND, length 11
       read_atom: returning sym 'MACROEXPAND'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 744)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 749)
        tokenize: returning '(' (length 1)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'get m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 751)
        tokenize: returning 'get' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' m :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 754)
        tokenize: returning 'm' (length 1)
       read_atom: received token get, length 3
       read_atom: returning sym 'get'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' :__MAL_MACRO__) (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 756)
        tokenize: returning ':__MAL_MACRO__' (length 14)
       read_atom: received token m, length 1
       read_atom: returning sym 'm'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 771)
        tokenize: returning ')' (length 1)
       read_atom: received token :__MAL_MACRO__, length 14
       read_atom: returning keyword :__MAL_MACRO__
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 772)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 774)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 778)
        tokenize: returning 'ast' (length 3)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 782)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 783)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 784)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 788)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      ast))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 789)
        tokenize: returning 'ast' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 799)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 800)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 801)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 802)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 803)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 806)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' eval-ast (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 810)
        tokenize: returning 'eval-ast' (length 8)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 819)
        tokenize: returning '(' (length 1)
       read_atom: received token eval-ast, length 8
       read_atom: returning sym 'eval-ast'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 821)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 824)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ast env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 826)
        tokenize: returning 'ast' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env]
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 829)
        tokenize: returning 'env' (length 3)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 833)
        tokenize: returning ']' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  ;; (do (prn "eval-ast" ast "/" (keys env)) )
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 834)
        tokenize: returning ';; (do (prn "eval-ast" ast "/" (keys env)) )' (length 44)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: read comment
        tokenize: called on '
  (cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 881)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'cond
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 885)
        tokenize: returning 'cond' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 889)
        tokenize: returning '(' (length 1)
       read_atom: received token cond, length 4
       read_atom: returning sym 'cond'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'symbol? ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 895)
        tokenize: returning 'symbol?' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast) (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 902)
        tokenize: returning 'ast' (length 3)
       read_atom: received token symbol?, length 7
       read_atom: returning sym 'symbol?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 906)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 907)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-get env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 909)
        tokenize: returning 'env-get' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 916)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-get, length 7
       read_atom: returning sym 'env-get'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 920)
        tokenize: returning 'ast' (length 3)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 924)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

    (list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 925)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list? ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 932)
        tokenize: returning 'list?' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 937)
        tokenize: returning 'ast' (length 3)
       read_atom: received token list?, length 5
       read_atom: returning sym 'list?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 941)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '   (map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 942)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'map (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 946)
        tokenize: returning 'map' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 949)
        tokenize: returning '(' (length 1)
       read_atom: received token map, length 3
       read_atom: returning sym 'map'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 951)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 954)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'exp] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 956)
        tokenize: returning 'exp' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '] (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 959)
        tokenize: returning ']' (length 1)
       read_atom: received token exp, length 3
       read_atom: returning sym 'exp'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 960)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 962)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' exp env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 966)
        tokenize: returning 'exp' (length 3)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 970)
        tokenize: returning 'env' (length 3)
       read_atom: received token exp, length 3
       read_atom: returning sym 'exp'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 974)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 975)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 976)
        tokenize: returning 'ast' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 980)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

    (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 981)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 988)
        tokenize: returning 'vector?' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 995)
        tokenize: returning 'ast' (length 3)
       read_atom: received token vector?, length 7
       read_atom: returning sym 'vector?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 999)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1000)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1002)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' vector (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1007)
        tokenize: returning 'vector' (length 6)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1014)
        tokenize: returning '(' (length 1)
       read_atom: received token vector, length 6
       read_atom: returning sym 'vector'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'map (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1016)
        tokenize: returning 'map' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1019)
        tokenize: returning '(' (length 1)
       read_atom: received token map, length 3
       read_atom: returning sym 'map'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1021)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1024)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'exp] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1026)
        tokenize: returning 'exp' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '] (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1029)
        tokenize: returning ']' (length 1)
       read_atom: received token exp, length 3
       read_atom: returning sym 'exp'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1030)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1032)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' exp env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1036)
        tokenize: returning 'exp' (length 3)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1040)
        tokenize: returning 'env' (length 3)
       read_atom: received token exp, length 3
       read_atom: returning sym 'exp'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1044)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1045)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1046)
        tokenize: returning 'ast' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1050)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1051)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

    (map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1052)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'map? ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1059)
        tokenize: returning 'map?' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1063)
        tokenize: returning 'ast' (length 3)
       read_atom: received token map?, length 4
       read_atom: returning sym 'map?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1067)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '    (apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1068)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1073)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' hash-map
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1078)
        tokenize: returning 'hash-map' (length 8)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
                    (apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1087)
        tokenize: returning '(' (length 1)
       read_atom: received token hash-map, length 8
       read_atom: returning sym 'hash-map'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1109)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' concat
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1114)
        tokenize: returning 'concat' (length 6)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
                      (map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1121)
        tokenize: returning '(' (length 1)
       read_atom: received token concat, length 6
       read_atom: returning sym 'concat'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'map (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1145)
        tokenize: returning 'map' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1148)
        tokenize: returning '(' (length 1)
       read_atom: received token map, length 3
       read_atom: returning sym 'map'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1150)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1153)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'k] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1155)
        tokenize: returning 'k' (length 1)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '] [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1156)
        tokenize: returning ']' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1157)
        tokenize: returning '[' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'k (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1159)
        tokenize: returning 'k' (length 1)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1160)
        tokenize: returning '(' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1162)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1166)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'get ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1168)
        tokenize: returning 'get' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1171)
        tokenize: returning 'ast' (length 3)
       read_atom: received token get, length 3
       read_atom: returning sym 'get'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k) env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1175)
        tokenize: returning 'k' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1177)
        tokenize: returning ')' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1178)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1182)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '])
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1183)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1184)
        tokenize: returning ')' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
                           (keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1185)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'keys ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1214)
        tokenize: returning 'keys' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1218)
        tokenize: returning 'ast' (length 3)
       read_atom: received token keys, length 4
       read_atom: returning sym 'keys'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1222)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1223)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1224)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1225)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

    "else"        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1226)
        tokenize: returning '"else"' (length 6)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '        ast)))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1238)
        tokenize: returning 'ast' (length 3)
       read_atom: received token "else", length 6
       read_atom: before remove_escapes 'else'
       read_atom: returning str 'else'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1249)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1250)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1251)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1252)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1255)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' LET (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1259)
        tokenize: returning 'LET' (length 3)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1263)
        tokenize: returning '(' (length 1)
       read_atom: received token LET, length 3
       read_atom: returning sym 'LET'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1265)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1268)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1270)
        tokenize: returning 'env' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' binds form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1273)
        tokenize: returning 'binds' (length 5)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' form]
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1279)
        tokenize: returning 'form' (length 4)
       read_atom: received token binds, length 5
       read_atom: returning sym 'binds'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1284)
        tokenize: returning ']' (length 1)
       read_atom: received token form, length 4
       read_atom: returning sym 'form'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1285)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1289)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1291)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'empty? binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1293)
        tokenize: returning 'empty?' (length 6)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' binds)
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1299)
        tokenize: returning 'binds' (length 5)
       read_atom: received token empty?, length 6
       read_atom: returning sym 'empty?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1305)
        tokenize: returning ')' (length 1)
       read_atom: received token binds, length 5
       read_atom: returning sym 'binds'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1306)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1312)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' form env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1316)
        tokenize: returning 'form' (length 4)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1321)
        tokenize: returning 'env' (length 3)
       read_atom: received token form, length 4
       read_atom: returning sym 'form'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1325)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1326)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'do
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1332)
        tokenize: returning 'do' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1334)
        tokenize: returning '(' (length 1)
       read_atom: received token do, length 2
       read_atom: returning sym 'do'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-set env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1342)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1349)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1353)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1355)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' binds) (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1360)
        tokenize: returning 'binds' (length 5)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1366)
        tokenize: returning ')' (length 1)
       read_atom: received token binds, length 5
       read_atom: returning sym 'binds'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1367)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1369)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1373)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1375)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' binds 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1378)
        tokenize: returning 'binds' (length 5)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1384)
        tokenize: returning '1' (length 1)
       read_atom: received token binds, length 5
       read_atom: returning sym 'binds'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1386)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1387)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1391)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1392)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1393)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'LET env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1401)
        tokenize: returning 'LET' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1404)
        tokenize: returning 'env' (length 3)
       read_atom: received token LET, length 3
       read_atom: returning sym 'LET'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1408)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1410)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1414)
        tokenize: returning '(' (length 1)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1416)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' binds)) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1420)
        tokenize: returning 'binds' (length 5)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1426)
        tokenize: returning ')' (length 1)
       read_atom: received token binds, length 5
       read_atom: returning sym 'binds'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1427)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' form)))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1428)
        tokenize: returning 'form' (length 4)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1433)
        tokenize: returning ')' (length 1)
       read_atom: received token form, length 4
       read_atom: returning sym 'form'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1434)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1435)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1436)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1437)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1438)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1441)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' EVAL (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1445)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1450)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1452)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1455)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ast env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1457)
        tokenize: returning 'ast' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env]
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1460)
        tokenize: returning 'env' (length 3)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1464)
        tokenize: returning ']' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  ;; (do (prn "EVAL" ast "/" (keys @env)) )
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1465)
        tokenize: returning ';; (do (prn "EVAL" ast "/" (keys @env)) )' (length 41)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: read comment
        tokenize: called on '
  (let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1509)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1513)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1517)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ast (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1519)
        tokenize: returning 'ast' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1522)
        tokenize: returning '(' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'MACROEXPAND ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1524)
        tokenize: returning 'MACROEXPAND' (length 11)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1535)
        tokenize: returning 'ast' (length 3)
       read_atom: received token MACROEXPAND, length 11
       read_atom: returning sym 'MACROEXPAND'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1539)
        tokenize: returning 'env' (length 3)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1543)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1544)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1545)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1551)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1553)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'not (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1555)
        tokenize: returning 'not' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1558)
        tokenize: returning '(' (length 1)
       read_atom: received token not, length 3
       read_atom: returning sym 'not'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'list? ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1560)
        tokenize: returning 'list?' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1565)
        tokenize: returning 'ast' (length 3)
       read_atom: received token list?, length 5
       read_atom: returning sym 'list?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1569)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1570)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1571)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'eval-ast ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1579)
        tokenize: returning 'eval-ast' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1587)
        tokenize: returning 'ast' (length 3)
       read_atom: received token eval-ast, length 8
       read_atom: returning sym 'eval-ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1591)
        tokenize: returning 'env' (length 3)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1595)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

      ;; apply list
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1596)
        tokenize: returning ';; apply list' (length 13)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
      (let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1617)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1625)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1629)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'a0 (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1631)
        tokenize: returning 'a0' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1633)
        tokenize: returning '(' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1635)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1640)
        tokenize: returning 'ast' (length 3)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1644)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1645)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
        (cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1646)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'cond
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1656)
        tokenize: returning 'cond' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1660)
        tokenize: returning '(' (length 1)
       read_atom: received token cond, length 4
       read_atom: returning sym 'cond'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'empty? ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1672)
        tokenize: returning 'empty?' (length 6)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast)
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1678)
        tokenize: returning 'ast' (length 3)
       read_atom: received token empty?, length 6
       read_atom: returning sym 'empty?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1682)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          ast

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1683)
        tokenize: returning 'ast' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1697)
        tokenize: returning '(' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1710)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1711)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'def! a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1713)
        tokenize: returning 'def!' (length 4)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1717)
        tokenize: returning 'a0' (length 2)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1720)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1721)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-set env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1733)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1740)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1744)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1746)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1749)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1753)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1755)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1756)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1758)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1762)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1764)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1767)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 2) env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1771)
        tokenize: returning '2' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1773)
        tokenize: returning ')' (length 1)
       read_atom: received token 2, length 1
       read_atom: returning int 2
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1774)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1778)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1779)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1780)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1793)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1794)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'let* a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1796)
        tokenize: returning 'let*' (length 4)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1800)
        tokenize: returning 'a0' (length 2)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1803)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1804)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'LET (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1816)
        tokenize: returning 'LET' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1819)
        tokenize: returning '(' (length 1)
       read_atom: received token LET, length 3
       read_atom: returning sym 'LET'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'new-env env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1821)
        tokenize: returning 'new-env' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env) (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1828)
        tokenize: returning 'env' (length 3)
       read_atom: received token new-env, length 7
       read_atom: returning sym 'new-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1832)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1833)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1835)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1838)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1842)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1844)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1845)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1847)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1850)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 2))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1854)
        tokenize: returning '2' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1856)
        tokenize: returning ')' (length 1)
       read_atom: received token 2, length 1
       read_atom: returning int 2
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1857)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1858)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1871)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1872)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'quote a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1874)
        tokenize: returning 'quote' (length 5)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1879)
        tokenize: returning 'a0' (length 2)
       read_atom: received token quote, length 5
       read_atom: returning sym 'quote'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1882)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1883)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1895)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1898)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1)

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1902)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1904)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1905)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1918)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1919)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'quasiquote a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1921)
        tokenize: returning 'quasiquote' (length 10)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1931)
        tokenize: returning 'a0' (length 2)
       read_atom: received token quasiquote, length 10
       read_atom: returning sym 'quasiquote'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1934)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1935)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1947)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1951)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'QUASIQUOTE (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1953)
        tokenize: returning 'QUASIQUOTE' (length 10)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1963)
        tokenize: returning '(' (length 1)
       read_atom: received token QUASIQUOTE, length 10
       read_atom: returning sym 'QUASIQUOTE'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1965)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1968)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1)) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1972)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1974)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1975)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1976)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1980)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1981)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1994)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1995)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'defmacro! a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 1997)
        tokenize: returning 'defmacro!' (length 9)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2006)
        tokenize: returning 'a0' (length 2)
       read_atom: received token defmacro!, length 9
       read_atom: returning sym 'defmacro!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2009)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2010)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-set env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2022)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2029)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2033)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2035)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2038)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2042)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2044)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2045)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'hash-map :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2047)
        tokenize: returning 'hash-map' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' :__MAL_MACRO__
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2055)
        tokenize: returning ':__MAL_MACRO__' (length 14)
       read_atom: received token hash-map, length 8
       read_atom: returning sym 'hash-map'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
                                             (EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2070)
        tokenize: returning '(' (length 1)
       read_atom: received token :__MAL_MACRO__, length 14
       read_atom: returning keyword :__MAL_MACRO__
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2117)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2121)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2123)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2126)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 2) env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2130)
        tokenize: returning '2' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2132)
        tokenize: returning ')' (length 1)
       read_atom: received token 2, length 1
       read_atom: returning int 2
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2133)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2137)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2138)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2139)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2140)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2153)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2154)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'macroexpand a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2156)
        tokenize: returning 'macroexpand' (length 11)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2167)
        tokenize: returning 'a0' (length 2)
       read_atom: received token macroexpand, length 11
       read_atom: returning sym 'macroexpand'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2170)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2171)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'MACROEXPAND (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2183)
        tokenize: returning 'MACROEXPAND' (length 11)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2194)
        tokenize: returning '(' (length 1)
       read_atom: received token MACROEXPAND, length 11
       read_atom: returning sym 'MACROEXPAND'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2196)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2199)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2203)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2205)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2206)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2210)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2211)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2224)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2225)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'do a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2227)
        tokenize: returning 'do' (length 2)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2229)
        tokenize: returning 'a0' (length 2)
       read_atom: received token do, length 2
       read_atom: returning sym 'do'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2232)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2233)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2245)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2249)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'el (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2251)
        tokenize: returning 'el' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2253)
        tokenize: returning '(' (length 1)
       read_atom: received token el, length 2
       read_atom: returning sym 'el'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'eval-ast (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2255)
        tokenize: returning 'eval-ast' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2263)
        tokenize: returning '(' (length 1)
       read_atom: received token eval-ast, length 8
       read_atom: returning sym 'eval-ast'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2265)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast) env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2269)
        tokenize: returning 'ast' (length 3)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2273)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2274)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2278)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2279)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
            (nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2280)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2294)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' el (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2297)
        tokenize: returning 'el' (length 2)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2300)
        tokenize: returning '(' (length 1)
       read_atom: received token el, length 2
       read_atom: returning sym 'el'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '- (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2302)
        tokenize: returning '-' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2303)
        tokenize: returning '(' (length 1)
       read_atom: received token -, length 1
       read_atom: returning sym '-'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'count el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2305)
        tokenize: returning 'count' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' el) 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2310)
        tokenize: returning 'el' (length 2)
       read_atom: received token count, length 5
       read_atom: returning sym 'count'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2313)
        tokenize: returning ')' (length 1)
       read_atom: received token el, length 2
       read_atom: returning sym 'el'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1)))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2314)
        tokenize: returning '1' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2316)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2317)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2318)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2319)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2332)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2333)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'if a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2335)
        tokenize: returning 'if' (length 2)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2337)
        tokenize: returning 'a0' (length 2)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2340)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2341)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2353)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2355)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2357)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2361)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2363)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2366)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2370)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2372)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2373)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2377)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
            (EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2378)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2392)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2396)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2398)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2401)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 2) env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2405)
        tokenize: returning '2' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2407)
        tokenize: returning ')' (length 1)
       read_atom: received token 2, length 1
       read_atom: returning int 2
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2408)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2412)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
            (if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2413)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2427)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2429)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '> (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2431)
        tokenize: returning '>' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2432)
        tokenize: returning '(' (length 1)
       read_atom: received token >, length 1
       read_atom: returning sym '>'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'count ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2434)
        tokenize: returning 'count' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast) 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2439)
        tokenize: returning 'ast' (length 3)
       read_atom: received token count, length 5
       read_atom: returning sym 'count'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2443)
        tokenize: returning ')' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 3)
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2444)
        tokenize: returning '3' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2446)
        tokenize: returning ')' (length 1)
       read_atom: received token 3, length 1
       read_atom: returning int 3
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
              (EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2447)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2463)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2467)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2469)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2472)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 3) env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2476)
        tokenize: returning '3' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2478)
        tokenize: returning ')' (length 1)
       read_atom: received token 3, length 1
       read_atom: returning int 3
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2479)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2483)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2484)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2485)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          (= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2486)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2499)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2500)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'fn* a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2502)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' a0)
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2505)
        tokenize: returning 'a0' (length 2)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2508)
        tokenize: returning ')' (length 1)
       read_atom: received token a0, length 2
       read_atom: returning sym 'a0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2509)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2521)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2524)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2526)
        tokenize: returning '&' (length 1)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2527)
        tokenize: returning 'args' (length 4)
       read_atom: received token &, length 1
       read_atom: returning sym '&'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '] (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2532)
        tokenize: returning ']' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2533)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2535)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2539)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2541)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2544)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 2) (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2548)
        tokenize: returning '2' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2550)
        tokenize: returning ')' (length 1)
       read_atom: received token 2, length 1
       read_atom: returning int 2
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2551)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'new-env env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2553)
        tokenize: returning 'new-env' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2560)
        tokenize: returning 'env' (length 3)
       read_atom: received token new-env, length 7
       read_atom: returning sym 'new-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2564)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2566)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2569)
        tokenize: returning 'ast' (length 3)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1) args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2573)
        tokenize: returning '1' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2575)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args)))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2576)
        tokenize: returning 'args' (length 4)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2581)
        tokenize: returning ')' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2582)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2583)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

          "else"
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2584)
        tokenize: returning '"else"' (length 6)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2602)
        tokenize: returning '(' (length 1)
       read_atom: received token "else", length 6
       read_atom: before remove_escapes 'else'
       read_atom: returning str 'else'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2614)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2618)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'el (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2620)
        tokenize: returning 'el' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2622)
        tokenize: returning '(' (length 1)
       read_atom: received token el, length 2
       read_atom: returning sym 'el'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'eval-ast ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2624)
        tokenize: returning 'eval-ast' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2632)
        tokenize: returning 'ast' (length 3)
       read_atom: received token eval-ast, length 8
       read_atom: returning sym 'eval-ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env)]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2636)
        tokenize: returning 'env' (length 3)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2640)
        tokenize: returning ')' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2641)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
            (apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2642)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2656)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2661)
        tokenize: returning '(' (length 1)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2663)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' el) (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2668)
        tokenize: returning 'el' (length 2)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2671)
        tokenize: returning ')' (length 1)
       read_atom: received token el, length 2
       read_atom: returning sym 'el'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2672)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2674)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' el)))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2678)
        tokenize: returning 'el' (length 2)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2681)
        tokenize: returning ')' (length 1)
       read_atom: received token el, length 2
       read_atom: returning sym 'el'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2682)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2683)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2684)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2685)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2686)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2687)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2688)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2689)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '


;; print
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2690)
        tokenize: returning ';; print' (length 8)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2701)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2703)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' PRINT pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2707)
        tokenize: returning 'PRINT' (length 5)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' pr-str)

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2713)
        tokenize: returning 'pr-str' (length 6)
       read_atom: received token PRINT, length 5
       read_atom: returning sym 'PRINT'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2720)
        tokenize: returning ')' (length 1)
       read_atom: received token pr-str, length 6
       read_atom: returning sym 'pr-str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2721)
        tokenize: returning ';; repl' (length 7)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2730)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2732)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-env (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2736)
        tokenize: returning 'repl-env' (length 8)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2745)
        tokenize: returning '(' (length 1)
       read_atom: received token repl-env, length 8
       read_atom: returning sym 'repl-env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'new-env))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2747)
        tokenize: returning 'new-env' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2754)
        tokenize: returning ')' (length 1)
       read_atom: received token new-env, length 7
       read_atom: returning sym 'new-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2755)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
(def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2756)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2758)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' rep (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2762)
        tokenize: returning 'rep' (length 3)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2766)
        tokenize: returning '(' (length 1)
       read_atom: received token rep, length 3
       read_atom: returning sym 'rep'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2768)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2771)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'strng]
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2773)
        tokenize: returning 'strng' (length 5)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2778)
        tokenize: returning ']' (length 1)
       read_atom: received token strng, length 5
       read_atom: returning sym 'strng'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2779)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'PRINT (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2783)
        tokenize: returning 'PRINT' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2788)
        tokenize: returning '(' (length 1)
       read_atom: received token PRINT, length 5
       read_atom: returning sym 'PRINT'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2790)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2794)
        tokenize: returning '(' (length 1)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'READ strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2796)
        tokenize: returning 'READ' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' strng) repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2800)
        tokenize: returning 'strng' (length 5)
       read_atom: received token READ, length 4
       read_atom: returning sym 'READ'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2806)
        tokenize: returning ')' (length 1)
       read_atom: received token strng, length 5
       read_atom: returning sym 'strng'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-env))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2807)
        tokenize: returning 'repl-env' (length 8)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2816)
        tokenize: returning ')' (length 1)
       read_atom: received token repl-env, length 8
       read_atom: returning sym 'repl-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2817)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2818)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2819)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

;; core.mal: defined directly using mal
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2820)
        tokenize: returning ';; core.mal: defined directly using mal' (length 39)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2861)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'map (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2863)
        tokenize: returning 'map' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2866)
        tokenize: returning '(' (length 1)
       read_atom: received token map, length 3
       read_atom: returning sym 'map'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2868)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2871)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'data] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2873)
        tokenize: returning 'data' (length 4)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '] (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2877)
        tokenize: returning ']' (length 1)
       read_atom: received token data, length 4
       read_atom: returning sym 'data'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2878)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2880)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env-set repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2885)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-env data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2893)
        tokenize: returning 'repl-env' (length 8)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' data)) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2902)
        tokenize: returning 'data' (length 4)
       read_atom: received token repl-env, length 8
       read_atom: returning sym 'repl-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2907)
        tokenize: returning ')' (length 1)
       read_atom: received token data, length 4
       read_atom: returning sym 'data'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2908)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2909)
        tokenize: returning 'core_ns' (length 7)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2917)
        tokenize: returning ')' (length 1)
       read_atom: received token core_ns, length 7
       read_atom: returning sym 'core_ns'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2918)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2920)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2927)
        tokenize: returning 'repl-env' (length 8)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2936)
        tokenize: returning ''' (length 1)
       read_atom: received token repl-env, length 8
       read_atom: returning sym 'repl-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2938)
        tokenize: returning 'eval' (length 4)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2942)
        tokenize: returning '(' (length 1)
       read_atom: received token eval, length 4
       read_atom: returning sym 'eval'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2944)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2947)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2949)
        tokenize: returning 'ast' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2952)
        tokenize: returning ']' (length 1)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2953)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2955)
        tokenize: returning 'EVAL' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2959)
        tokenize: returning 'ast' (length 3)
       read_atom: received token EVAL, length 4
       read_atom: returning sym 'EVAL'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2963)
        tokenize: returning 'repl-env' (length 8)
       read_atom: received token ast, length 3
       read_atom: returning sym 'ast'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2972)
        tokenize: returning ')' (length 1)
       read_atom: received token repl-env, length 8
       read_atom: returning sym 'repl-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2973)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2974)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2975)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2977)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2984)
        tokenize: returning 'repl-env' (length 8)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2993)
        tokenize: returning ''' (length 1)
       read_atom: received token repl-env, length 8
       read_atom: returning sym 'repl-env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 2995)
        tokenize: returning '*ARGV*' (length 6)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3001)
        tokenize: returning '(' (length 1)
       read_atom: received token *ARGV*, length 6
       read_atom: returning sym '*ARGV*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3003)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' *ARGV*))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3007)
        tokenize: returning '*ARGV*' (length 6)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3014)
        tokenize: returning ')' (length 1)
       read_atom: received token *ARGV*, length 6
       read_atom: returning sym '*ARGV*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3015)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

;; core.mal: defined using the new language itself
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3016)
        tokenize: returning ';; core.mal: defined using the new language itself' (length 50)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3068)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3070)
        tokenize: returning 'rep' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3073)
        tokenize: returning '"(def! not (fn* [a] (if a false true)))"' (length 40)
       read_atom: received token rep, length 3
       read_atom: returning sym 'rep'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3114)
        tokenize: returning ')' (length 1)
       read_atom: received token "(def! not (fn* [a] (if a false true)))", length 40
       read_atom: before remove_escapes '(def! not (fn* [a] (if a false true)))'
       read_atom: returning str '(def! not (fn* [a] (if a false true)))'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3115)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3117)
        tokenize: returning 'rep' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3120)
        tokenize: returning '"(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))"' (length 85)
       read_atom: received token rep, length 3
       read_atom: returning sym 'rep'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3206)
        tokenize: returning ')' (length 1)
       read_atom: received token "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))", length 85
       read_atom: before remove_escapes '(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))'
       read_atom: returning str '(def! load-file (fn* (f) (eval (read-string (str "(do " (slurp f) "
nil)")))))'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3207)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3209)
        tokenize: returning 'rep' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3212)
        tokenize: returning '"(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))"' (length 178)
       read_atom: received token rep, length 3
       read_atom: returning sym 'rep'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3391)
        tokenize: returning ')' (length 1)
       read_atom: received token "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))", length 178
       read_atom: before remove_escapes '(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))'
       read_atom: returning str '(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw "odd number of forms to cond")) (cons 'cond (rest (rest xs)))))))'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

;; repl loop
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3392)
        tokenize: returning ';; repl loop' (length 12)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3406)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3408)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' repl-loop (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3412)
        tokenize: returning 'repl-loop' (length 9)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3422)
        tokenize: returning '(' (length 1)
       read_atom: received token repl-loop, length 9
       read_atom: returning sym 'repl-loop'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3424)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3427)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'line]
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3429)
        tokenize: returning 'line' (length 4)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3433)
        tokenize: returning ']' (length 1)
       read_atom: received token line, length 4
       read_atom: returning sym 'line'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3434)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3438)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' line
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3440)
        tokenize: returning 'line' (length 4)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3445)
        tokenize: returning '(' (length 1)
       read_atom: received token line, length 4
       read_atom: returning sym 'line'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'do
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3451)
        tokenize: returning 'do' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3453)
        tokenize: returning '(' (length 1)
       read_atom: received token do, length 2
       read_atom: returning sym 'do'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3461)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3463)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'not (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3465)
        tokenize: returning 'not' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3468)
        tokenize: returning '(' (length 1)
       read_atom: received token not, length 3
       read_atom: returning sym 'not'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3470)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "" line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3471)
        tokenize: returning '""' (length 2)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' line))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3474)
        tokenize: returning 'line' (length 4)
       read_atom: received token "", length 2
       read_atom: before remove_escapes ''
       read_atom: returning str ''
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3479)
        tokenize: returning ')' (length 1)
       read_atom: received token line, length 4
       read_atom: returning sym 'line'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3480)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
        (try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3481)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'try*
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3491)
        tokenize: returning 'try*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3495)
        tokenize: returning '(' (length 1)
       read_atom: received token try*, length 4
       read_atom: returning sym 'try*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'println (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3507)
        tokenize: returning 'println' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3514)
        tokenize: returning '(' (length 1)
       read_atom: received token println, length 7
       read_atom: returning sym 'println'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rep line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3516)
        tokenize: returning 'rep' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' line))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3519)
        tokenize: returning 'line' (length 4)
       read_atom: received token rep, length 3
       read_atom: returning sym 'rep'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3524)
        tokenize: returning ')' (length 1)
       read_atom: received token line, length 4
       read_atom: returning sym 'line'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3525)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
          (catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3526)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'catch* exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3538)
        tokenize: returning 'catch*' (length 6)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' exc
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3544)
        tokenize: returning 'exc' (length 3)
       read_atom: received token catch*, length 6
       read_atom: returning sym 'catch*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
            (println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3548)
        tokenize: returning '(' (length 1)
       read_atom: received token exc, length 3
       read_atom: returning sym 'exc'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'println "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3562)
        tokenize: returning 'println' (length 7)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "Uncaught exception:" exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3569)
        tokenize: returning '"Uncaught exception:"' (length 21)
       read_atom: received token println, length 7
       read_atom: returning sym 'println'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' exc))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3591)
        tokenize: returning 'exc' (length 3)
       read_atom: received token "Uncaught exception:", length 21
       read_atom: before remove_escapes 'Uncaught exception:'
       read_atom: returning str 'Uncaught exception:'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3595)
        tokenize: returning ')' (length 1)
       read_atom: received token exc, length 3
       read_atom: returning sym 'exc'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3596)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3597)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3598)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3599)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'repl-loop (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3607)
        tokenize: returning 'repl-loop' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3616)
        tokenize: returning '(' (length 1)
       read_atom: received token repl-loop, length 9
       read_atom: returning sym 'repl-loop'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'readline "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3618)
        tokenize: returning 'readline' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "mal-user> "))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3626)
        tokenize: returning '"mal-user> "' (length 12)
       read_atom: received token readline, length 8
       read_atom: returning sym 'readline'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3639)
        tokenize: returning ')' (length 1)
       read_atom: received token "mal-user> ", length 12
       read_atom: before remove_escapes 'mal-user> '
       read_atom: returning str 'mal-user> '
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3640)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3641)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3642)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3643)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3644)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

;; main
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3645)
        tokenize: returning ';; main' (length 7)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: read comment
        tokenize: called on '
(if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3654)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3656)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3658)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'empty? *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3660)
        tokenize: returning 'empty?' (length 6)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' *ARGV*)
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3666)
        tokenize: returning '*ARGV*' (length 6)
       read_atom: received token empty?, length 6
       read_atom: returning sym 'empty?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3673)
        tokenize: returning ')' (length 1)
       read_atom: received token *ARGV*, length 6
       read_atom: returning sym '*ARGV*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3674)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'repl-loop "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3678)
        tokenize: returning 'repl-loop' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "")
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3687)
        tokenize: returning '""' (length 2)
       read_atom: received token repl-loop, length 9
       read_atom: returning sym 'repl-loop'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3690)
        tokenize: returning ')' (length 1)
       read_atom: received token "", length 2
       read_atom: before remove_escapes ''
       read_atom: returning str ''
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3691)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rep (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3695)
        tokenize: returning 'rep' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3698)
        tokenize: returning '(' (length 1)
       read_atom: received token rep, length 3
       read_atom: returning sym 'rep'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3700)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "(load-file \"" (first *ARGV*) "\")")))

nil) ' (offset 3703)
        tokenize: returning '"(load-file \""' (length 15)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first *ARGV*) "\")")))

nil) ' (offset 3719)
        tokenize: returning '(' (length 1)
       read_atom: received token "(load-file \"", length 15
       read_atom: before remove_escapes '(load-file \"'
       read_atom: returning str '(load-file "'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first *ARGV*) "\")")))

nil) ' (offset 3721)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' *ARGV*) "\")")))

nil) ' (offset 3726)
        tokenize: returning '*ARGV*' (length 6)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') "\")")))

nil) ' (offset 3733)
        tokenize: returning ')' (length 1)
       read_atom: received token *ARGV*, length 6
       read_atom: returning sym '*ARGV*'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "\")")))

nil) ' (offset 3734)
        tokenize: returning '"\")"' (length 5)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

nil) ' (offset 3740)
        tokenize: returning ')' (length 1)
       read_atom: received token "\")", length 5
       read_atom: before remove_escapes '\")'
       read_atom: returning str '")'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

nil) ' (offset 3741)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

nil) ' (offset 3742)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

nil) ' (offset 3743)
        tokenize: returning 'nil' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') ' (offset 3748)
        tokenize: returning ')' (length 1)
       read_atom: received token nil, length 3
       read_atom: returning nil
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ' (offset 3749)
        tokenize: found nothing (zero length token)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
            eval: after args evaluated have (<function> (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil))
       mal_first: called with (<function> (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil))
        mal_rest: called with (<function> (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil))
            eval: head of list to be applied <function>
            eval: rest of list to be applied ((do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil))
        mal_eval: called with ((do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil))
            eval: called with (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
   is_macro_call: called with (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
       mal_first: called with (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
         env_get: getting do
        env_find: finding do in 0x7fa723c1c000
          ht_has: called for key do
          ht_has: called for key do
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
       mal_first: called with (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
        mal_rest: called with (do (load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
do_special_form_before_continue:  ((load-file "../mal/env.mal") (load-file "../mal/core.mal") (def! READ read-string) (def! is-pair (fn* [x] (if (sequential? x) (not (empty? x))))) (def! QUASIQUOTE (fn* [ast] (if (not (is-pair ast)) (list (quote quote) ast) (let* [a0 (first ast)] (cond (= (quote unquote) a0) (nth ast 1) (if (is-pair a0) (= (quote splice-unquote) (first a0))) (list (quote concat) (nth a0 1) (QUASIQUOTE (rest ast))) "else" (list (quote cons) (QUASIQUOTE a0) (QUASIQUOTE (rest ast)))))))) (def! MACROEXPAND (fn* [ast env] (let* [a0 (if (list? ast) (first ast)) e (if (symbol? a0) (env-find env a0)) m (if e (env-get e a0))] (if (_macro? m) (MACROEXPAND (apply (get m :__MAL_MACRO__) (rest ast)) env) ast)))) (def! eval-ast (fn* [ast env] (cond (symbol? ast) (env-get env ast) (list? ast) (map (fn* [exp] (EVAL exp env)) ast) (vector? ast) (apply vector (map (fn* [exp] (EVAL exp env)) ast)) (map? ast) (apply hash-map (apply concat (map (fn* [k] [k (EVAL (get ast k) env)]) (keys ast)))) "else" ast))) (def! LET (fn* [env binds form] (if (empty? binds) (EVAL form env) (do (env-set env (first binds) (EVAL (nth binds 1) env)) (LET env (rest (rest binds)) form))))) (def! EVAL (fn* [ast env] (let* [ast (MACROEXPAND ast env)] (if (not (list? ast)) (eval-ast ast env) (let* [a0 (first ast)] (cond (empty? ast) ast (= (quote def!) a0) (env-set env (nth ast 1) (EVAL (nth ast 2) env)) (= (quote let*) a0) (LET (new-env env) (nth ast 1) (nth ast 2)) (= (quote quote) a0) (nth ast 1) (= (quote quasiquote) a0) (EVAL (QUASIQUOTE (nth ast 1)) env) (= (quote defmacro!) a0) (env-set env (nth ast 1) (hash-map :__MAL_MACRO__ (EVAL (nth ast 2) env))) (= (quote macroexpand) a0) (MACROEXPAND (nth ast 1) env) (= (quote do) a0) (let* [el (eval-ast (rest ast) env)] (nth el (- (count el) 1))) (= (quote if) a0) (if (EVAL (nth ast 1) env) (EVAL (nth ast 2) env) (if (> (count ast) 3) (EVAL (nth ast 3) env))) (= (quote fn*) a0) (fn* [& args] (EVAL (nth ast 2) (new-env env (nth ast 1) args))) "else" (let* [el (eval-ast ast env)] (apply (first el) (rest el))))))))) (def! PRINT pr-str) (def! repl-env (new-env)) (def! rep (fn* [strng] (PRINT (EVAL (READ strng) repl-env)))) (map (fn* [data] (apply env-set repl-env data)) core_ns) (env-set repl-env (quote eval) (fn* [ast] (EVAL ast repl-env))) (env-set repl-env (quote *ARGV*) (rest *ARGV*)) (rep "(def! not (fn* [a] (if a false true)))") (rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \"\nnil)\")))))") (rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))") (def! repl-loop (fn* [line] (if line (do (if (not (= "" line)) (try* (println (rep line)) (catch* exc (println "Uncaught exception:" exc)))) (repl-loop (readline "mal-user> ")))))) (if (empty? *ARGV*) (repl-loop "") (rep (str "(load-file \"" (first *ARGV*) "\")"))) nil)
            eval: called with (load-file "../mal/env.mal")
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (load-file "../mal/env.mal")
   is_macro_call: called with (load-file "../mal/env.mal")
       mal_first: called with (load-file "../mal/env.mal")
         env_get: getting load-file
        env_find: finding load-file in 0x7fa723c1c000
          ht_has: called for key load-file
          ht_has: called for key load-file
         env_get: found 0x7fa723c05860
          ht_get: called for key load-file
         env_get: returning load-file <function>
   is_macro_call: returning FALSE
            eval: macro expanded (load-file "../mal/env.mal")
       mal_first: called with (load-file "../mal/env.mal")
        mal_rest: called with (load-file "../mal/env.mal")
        eval_ast: called with (load-file "../mal/env.mal")
            eval: called with load-file
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with load-file
   is_macro_call: called with load-file
            eval: macro expanded load-file
        eval_ast: called with load-file
         env_get: getting load-file
        env_find: finding load-file in 0x7fa723c1c000
          ht_has: called for key load-file
          ht_has: called for key load-file
         env_get: found 0x7fa723c05860
          ht_get: called for key load-file
         env_get: returning load-file <function>
            eval: called with "../mal/env.mal"
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with "../mal/env.mal"
   is_macro_call: called with "../mal/env.mal"
            eval: macro expanded "../mal/env.mal"
        eval_ast: called with "../mal/env.mal"
            eval: after args evaluated have (<function> "../mal/env.mal")
       mal_first: called with (<function> "../mal/env.mal")
        mal_rest: called with (<function> "../mal/env.mal")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("../mal/env.mal")
        env_new2: called with outer 0x7fa723c05860
   ht_from_lists: called with 1 1 keys
          ht_new: called for 1 entries
   ht_from_lists: in while
          ht_put: called for key f
        env_new2: returning 0x7fa723ca1440
            eval: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
   is_macro_call: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
       mal_first: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
         env_get: getting eval
        env_find: finding eval in 0x7fa723ca1440
          ht_has: called for key eval
          ht_has: called for key eval
         env_get: found 0x7fa723c05860
          ht_get: called for key eval
         env_get: returning eval <function>
   is_macro_call: returning FALSE
            eval: macro expanded (eval (read-string (str "(do " (slurp f) "\nnil) ")))
       mal_first: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
        mal_rest: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
        eval_ast: called with (eval (read-string (str "(do " (slurp f) "\nnil) ")))
            eval: called with eval
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with eval
   is_macro_call: called with eval
            eval: macro expanded eval
        eval_ast: called with eval
         env_get: getting eval
        env_find: finding eval in 0x7fa723ca1440
          ht_has: called for key eval
          ht_has: called for key eval
         env_get: found 0x7fa723c05860
          ht_get: called for key eval
         env_get: returning eval <function>
            eval: called with (read-string (str "(do " (slurp f) "\nnil) "))
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with (read-string (str "(do " (slurp f) "\nnil) "))
   is_macro_call: called with (read-string (str "(do " (slurp f) "\nnil) "))
       mal_first: called with (read-string (str "(do " (slurp f) "\nnil) "))
         env_get: getting read-string
        env_find: finding read-string in 0x7fa723ca1440
          ht_has: called for key read-string
          ht_has: called for key read-string
         env_get: found 0x7fa723c05860
          ht_get: called for key read-string
         env_get: returning read-string <function>
   is_macro_call: returning FALSE
            eval: macro expanded (read-string (str "(do " (slurp f) "\nnil) "))
       mal_first: called with (read-string (str "(do " (slurp f) "\nnil) "))
        mal_rest: called with (read-string (str "(do " (slurp f) "\nnil) "))
        eval_ast: called with (read-string (str "(do " (slurp f) "\nnil) "))
            eval: called with read-string
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with read-string
   is_macro_call: called with read-string
            eval: macro expanded read-string
        eval_ast: called with read-string
         env_get: getting read-string
        env_find: finding read-string in 0x7fa723ca1440
          ht_has: called for key read-string
          ht_has: called for key read-string
         env_get: found 0x7fa723c05860
          ht_get: called for key read-string
         env_get: returning read-string <function>
            eval: called with (str "(do " (slurp f) "\nnil) ")
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with (str "(do " (slurp f) "\nnil) ")
   is_macro_call: called with (str "(do " (slurp f) "\nnil) ")
       mal_first: called with (str "(do " (slurp f) "\nnil) ")
         env_get: getting str
        env_find: finding str in 0x7fa723ca1440
          ht_has: called for key str
          ht_has: called for key str
         env_get: found 0x7fa723c05860
          ht_get: called for key str
         env_get: returning str <function>
   is_macro_call: returning FALSE
            eval: macro expanded (str "(do " (slurp f) "\nnil) ")
       mal_first: called with (str "(do " (slurp f) "\nnil) ")
        mal_rest: called with (str "(do " (slurp f) "\nnil) ")
        eval_ast: called with (str "(do " (slurp f) "\nnil) ")
            eval: called with str
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with str
   is_macro_call: called with str
            eval: macro expanded str
        eval_ast: called with str
         env_get: getting str
        env_find: finding str in 0x7fa723ca1440
          ht_has: called for key str
          ht_has: called for key str
         env_get: found 0x7fa723c05860
          ht_get: called for key str
         env_get: returning str <function>
            eval: called with "(do "
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with "(do "
   is_macro_call: called with "(do "
            eval: macro expanded "(do "
        eval_ast: called with "(do "
            eval: called with (slurp f)
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with (slurp f)
   is_macro_call: called with (slurp f)
       mal_first: called with (slurp f)
         env_get: getting slurp
        env_find: finding slurp in 0x7fa723ca1440
          ht_has: called for key slurp
          ht_has: called for key slurp
         env_get: found 0x7fa723c05860
          ht_get: called for key slurp
         env_get: returning slurp <function>
   is_macro_call: returning FALSE
            eval: macro expanded (slurp f)
       mal_first: called with (slurp f)
        mal_rest: called with (slurp f)
        eval_ast: called with (slurp f)
            eval: called with slurp
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with slurp
   is_macro_call: called with slurp
            eval: macro expanded slurp
        eval_ast: called with slurp
         env_get: getting slurp
        env_find: finding slurp in 0x7fa723ca1440
          ht_has: called for key slurp
          ht_has: called for key slurp
         env_get: found 0x7fa723c05860
          ht_get: called for key slurp
         env_get: returning slurp <function>
            eval: called with f
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with f
   is_macro_call: called with f
            eval: macro expanded f
        eval_ast: called with f
         env_get: getting f
        env_find: finding f in 0x7fa723ca1440
          ht_has: called for key f
         env_get: found 0x7fa723ca1440
          ht_get: called for key f
         env_get: returning f "../mal/env.mal"
            eval: after args evaluated have (<function> "../mal/env.mal")
       mal_first: called with (<function> "../mal/env.mal")
        mal_rest: called with (<function> "../mal/env.mal")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("../mal/env.mal")
      core_slurp: called with ("../mal/env.mal")
            eval: called with "\nnil) "
environment: 1440 (outer=core)
  "f" -> "../mal/env.mal"
     macroexpand: called with "\nnil) "
   is_macro_call: called with "\nnil) "
            eval: macro expanded "\nnil) "
        eval_ast: called with "\nnil) "
            eval: after args evaluated have (<function> "(do " "(def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n" "\nnil) ")
       mal_first: called with (<function> "(do " "(def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n" "\nnil) ")
        mal_rest: called with (<function> "(do " "(def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n" "\nnil) ")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("(do " "(def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n" "\nnil) ")
        core_str: called with ("(do " "(def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n" "\nnil) ")
            eval: after args evaluated have (<function> "(do (def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n\nnil) ")
       mal_first: called with (<function> "(do (def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n\nnil) ")
        mal_rest: called with (<function> "(do (def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n\nnil) ")
            eval: head of list to be applied <function>
            eval: rest of list to be applied ("(do (def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n\nnil) ")
core_read_string: called with ("(do (def! bind-env (fn* [env b e]\n  (if (empty? b)\n    env\n    (let* [b0 (first b)]\n      (if (= '& b0)\n        (assoc env (str (nth b 1)) e)\n        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))\n\n(def! new-env (fn* [& args]\n  (if (<= (count args) 1)\n    (atom {:outer (first args)})\n    (atom (apply bind-env {:outer (first args)} (rest args))))))\n\n(def! env-find (fn* [env k]\n  (env-find-str env (str k))))\n\n(def! env-find-str (fn* [env ks]\n  (if env\n    (let* [data @env]\n      (if (contains? data ks)\n        env\n        (env-find-str (get data :outer) ks))))))\n\n(def! env-get (fn* [env k]\n  (let* [ks (str k)\n         e (env-find-str env ks)]\n    (if e\n      (get @e ks)\n      (throw (str \"'\" ks \"' not found\"))))))\n\n(def! env-set (fn* [env k v]\n  (do\n    (swap! env assoc (str k) v)\n    v)))\n\nnil) ")
        read_str: called on '(do (def! bind-env (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) '
        tokenize: called on '(do (def! bind-env (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 0)
        tokenize: returning '(' (length 1)
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'do (def! bind-env (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 1)
        tokenize: returning 'do' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (def! bind-env (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 3)
        tokenize: returning '(' (length 1)
       read_atom: received token do, length 2
       read_atom: returning sym 'do'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! bind-env (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 5)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' bind-env (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 9)
        tokenize: returning 'bind-env' (length 8)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 18)
        tokenize: returning '(' (length 1)
       read_atom: received token bind-env, length 8
       read_atom: returning sym 'bind-env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 20)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 23)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 25)
        tokenize: returning 'env' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 28)
        tokenize: returning 'b' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e]
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 30)
        tokenize: returning 'e' (length 1)
       read_atom: received token b, length 1
       read_atom: returning sym 'b'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 32)
        tokenize: returning ']' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 33)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 37)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 39)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'empty? b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 41)
        tokenize: returning 'empty?' (length 6)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b)
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 47)
        tokenize: returning 'b' (length 1)
       read_atom: received token empty?, length 6
       read_atom: returning sym 'empty?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 49)
        tokenize: returning ')' (length 1)
       read_atom: received token b, length 1
       read_atom: returning sym 'b'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    env
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 50)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 58)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 64)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 68)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'b0 (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 70)
        tokenize: returning 'b0' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 72)
        tokenize: returning '(' (length 1)
       read_atom: received token b0, length 2
       read_atom: returning sym 'b0'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 74)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b)]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 79)
        tokenize: returning 'b' (length 1)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 81)
        tokenize: returning ')' (length 1)
       read_atom: received token b, length 1
       read_atom: returning sym 'b'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 82)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 83)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 91)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 93)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '= '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 95)
        tokenize: returning '=' (length 1)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 96)
        tokenize: returning ''' (length 1)
       read_atom: received token =, length 1
       read_atom: returning sym '='
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '& b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 98)
        tokenize: returning '&' (length 1)
       read_atom: received token ', length 1
       read_atom: expanding quote
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b0)
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 99)
        tokenize: returning 'b0' (length 2)
       read_atom: received token &, length 1
       read_atom: returning sym '&'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 102)
        tokenize: returning ')' (length 1)
       read_atom: received token b0, length 2
       read_atom: returning sym 'b0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
        (assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 103)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'assoc env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 113)
        tokenize: returning 'assoc' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 118)
        tokenize: returning 'env' (length 3)
       read_atom: received token assoc, length 5
       read_atom: returning sym 'assoc'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 122)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 124)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 127)
        tokenize: returning '(' (length 1)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'nth b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 129)
        tokenize: returning 'nth' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 132)
        tokenize: returning 'b' (length 1)
       read_atom: received token nth, length 3
       read_atom: returning sym 'nth'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1)) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 134)
        tokenize: returning '1' (length 1)
       read_atom: received token b, length 1
       read_atom: returning sym 'b'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 136)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 137)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e)
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 138)
        tokenize: returning 'e' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 140)
        tokenize: returning ')' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
        (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 141)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 151)
        tokenize: returning 'bind-env' (length 8)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 159)
        tokenize: returning '(' (length 1)
       read_atom: received token bind-env, length 8
       read_atom: returning sym 'bind-env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'assoc env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 161)
        tokenize: returning 'assoc' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 166)
        tokenize: returning 'env' (length 3)
       read_atom: received token assoc, length 5
       read_atom: returning sym 'assoc'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 170)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 172)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b0) (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 175)
        tokenize: returning 'b0' (length 2)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 178)
        tokenize: returning ')' (length 1)
       read_atom: received token b0, length 2
       read_atom: returning sym 'b0'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 179)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 181)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e)) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 186)
        tokenize: returning 'e' (length 1)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')) (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 188)
        tokenize: returning ')' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 189)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 190)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 192)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' b) (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 196)
        tokenize: returning 'b' (length 1)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 198)
        tokenize: returning ')' (length 1)
       read_atom: received token b, length 1
       read_atom: returning sym 'b'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 199)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 201)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e)))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 205)
        tokenize: returning 'e' (length 1)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 207)
        tokenize: returning ')' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 208)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 209)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 210)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 211)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 212)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 213)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 214)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 217)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' new-env (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 221)
        tokenize: returning 'new-env' (length 7)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 229)
        tokenize: returning '(' (length 1)
       read_atom: received token new-env, length 7
       read_atom: returning sym 'new-env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 231)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 234)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '& args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 236)
        tokenize: returning '&' (length 1)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args]
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 237)
        tokenize: returning 'args' (length 4)
       read_atom: received token &, length 1
       read_atom: returning sym '&'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 242)
        tokenize: returning ']' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 243)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 247)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 249)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on '<= (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 251)
        tokenize: returning '<=' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 253)
        tokenize: returning '(' (length 1)
       read_atom: received token <=, length 2
       read_atom: returning sym '<='
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'count args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 255)
        tokenize: returning 'count' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args) 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 260)
        tokenize: returning 'args' (length 4)
       read_atom: received token count, length 5
       read_atom: returning sym 'count'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 265)
        tokenize: returning ')' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' 1)
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 266)
        tokenize: returning '1' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 268)
        tokenize: returning ')' (length 1)
       read_atom: received token 1, length 1
       read_atom: returning int 1
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 269)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'atom {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 275)
        tokenize: returning 'atom' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' {:outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 279)
        tokenize: returning '{' (length 1)
       read_atom: received token atom, length 4
       read_atom: returning sym 'atom'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on ':outer (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 281)
        tokenize: returning ':outer' (length 6)
       read_atom: received token {, length 1
       read_atom: returning sym '{'
   read_extended: map
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 287)
        tokenize: returning '(' (length 1)
       read_atom: received token :outer, length 6
       read_atom: returning keyword :outer
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 289)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args)})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 294)
        tokenize: returning 'args' (length 4)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 299)
        tokenize: returning ')' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '})
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 300)
        tokenize: returning '}' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 301)
        tokenize: returning ')' (length 1)
       read_atom: received token }, length 1
       read_atom: returning sym '}'
ht_from_alternating_list: called with 2 elements
          ht_new: called for 1 entries
          ht_put: called for key outer
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 302)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'atom (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 308)
        tokenize: returning 'atom' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 312)
        tokenize: returning '(' (length 1)
       read_atom: received token atom, length 4
       read_atom: returning sym 'atom'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'apply bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 314)
        tokenize: returning 'apply' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' bind-env {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 319)
        tokenize: returning 'bind-env' (length 8)
       read_atom: received token apply, length 5
       read_atom: returning sym 'apply'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' {:outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 328)
        tokenize: returning '{' (length 1)
       read_atom: received token bind-env, length 8
       read_atom: returning sym 'bind-env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on ':outer (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 330)
        tokenize: returning ':outer' (length 6)
       read_atom: received token {, length 1
       read_atom: returning sym '{'
   read_extended: map
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 336)
        tokenize: returning '(' (length 1)
       read_atom: received token :outer, length 6
       read_atom: returning keyword :outer
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'first args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 338)
        tokenize: returning 'first' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args)} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 343)
        tokenize: returning 'args' (length 4)
       read_atom: received token first, length 5
       read_atom: returning sym 'first'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 348)
        tokenize: returning ')' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '} (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 349)
        tokenize: returning '}' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 350)
        tokenize: returning '(' (length 1)
       read_atom: received token }, length 1
       read_atom: returning sym '}'
ht_from_alternating_list: called with 2 elements
          ht_new: called for 1 entries
          ht_put: called for key outer
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'rest args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 352)
        tokenize: returning 'rest' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' args))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 356)
        tokenize: returning 'args' (length 4)
       read_atom: received token rest, length 4
       read_atom: returning sym 'rest'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 361)
        tokenize: returning ')' (length 1)
       read_atom: received token args, length 4
       read_atom: returning sym 'args'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 362)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 363)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 364)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 365)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 366)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 367)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 370)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env-find (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 374)
        tokenize: returning 'env-find' (length 8)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 383)
        tokenize: returning '(' (length 1)
       read_atom: received token env-find, length 8
       read_atom: returning sym 'env-find'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 385)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 388)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 390)
        tokenize: returning 'env' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k]
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 393)
        tokenize: returning 'k' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 395)
        tokenize: returning ']' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 396)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-find-str env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 400)
        tokenize: returning 'env-find-str' (length 12)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 412)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-find-str, length 12
       read_atom: returning sym 'env-find-str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 416)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 418)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 421)
        tokenize: returning 'k' (length 1)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 423)
        tokenize: returning ')' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 424)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 425)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 426)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 427)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 430)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env-find-str (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 434)
        tokenize: returning 'env-find-str' (length 12)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 447)
        tokenize: returning '(' (length 1)
       read_atom: received token env-find-str, length 12
       read_atom: returning sym 'env-find-str'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 449)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 452)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 454)
        tokenize: returning 'env' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ks]
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 457)
        tokenize: returning 'ks' (length 2)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 460)
        tokenize: returning ']' (length 1)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 461)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 465)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 467)
        tokenize: returning 'env' (length 3)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 471)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 477)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 481)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'data @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 483)
        tokenize: returning 'data' (length 4)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' @env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 487)
        tokenize: returning '@' (length 1)
       read_atom: received token data, length 4
       read_atom: returning sym 'data'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'env]
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 489)
        tokenize: returning 'env' (length 3)
       read_atom: received token @, length 1
       read_atom: expanding deref
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 492)
        tokenize: returning ']' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 493)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 501)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 503)
        tokenize: returning '(' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'contains? data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 505)
        tokenize: returning 'contains?' (length 9)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' data ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 514)
        tokenize: returning 'data' (length 4)
       read_atom: received token contains?, length 9
       read_atom: returning sym 'contains?'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ks)
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 519)
        tokenize: returning 'ks' (length 2)
       read_atom: received token data, length 4
       read_atom: returning sym 'data'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 522)
        tokenize: returning ')' (length 1)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
        env
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 523)
        tokenize: returning 'env' (length 3)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
        (env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 535)
        tokenize: returning '(' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-find-str (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 545)
        tokenize: returning 'env-find-str' (length 12)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 557)
        tokenize: returning '(' (length 1)
       read_atom: received token env-find-str, length 12
       read_atom: returning sym 'env-find-str'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'get data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 559)
        tokenize: returning 'get' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' data :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 562)
        tokenize: returning 'data' (length 4)
       read_atom: received token get, length 3
       read_atom: returning sym 'get'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' :outer) ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 567)
        tokenize: returning ':outer' (length 6)
       read_atom: received token data, length 4
       read_atom: returning sym 'data'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 574)
        tokenize: returning ')' (length 1)
       read_atom: received token :outer, length 6
       read_atom: returning keyword :outer
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ks))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 575)
        tokenize: returning 'ks' (length 2)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 578)
        tokenize: returning ')' (length 1)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 579)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 580)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 581)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 582)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 583)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 584)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 587)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env-get (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 591)
        tokenize: returning 'env-get' (length 7)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 599)
        tokenize: returning '(' (length 1)
       read_atom: received token env-get, length 7
       read_atom: returning sym 'env-get'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 601)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 604)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 606)
        tokenize: returning 'env' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k]
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 609)
        tokenize: returning 'k' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 611)
        tokenize: returning ']' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 612)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'let* [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 616)
        tokenize: returning 'let*' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 620)
        tokenize: returning '[' (length 1)
       read_atom: received token let*, length 4
       read_atom: returning sym 'let*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'ks (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 622)
        tokenize: returning 'ks' (length 2)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 624)
        tokenize: returning '(' (length 1)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 626)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k)
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 629)
        tokenize: returning 'k' (length 1)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 631)
        tokenize: returning ')' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
         e (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 632)
        tokenize: returning 'e' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 643)
        tokenize: returning '(' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env-find-str env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 645)
        tokenize: returning 'env-find-str' (length 12)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 657)
        tokenize: returning 'env' (length 3)
       read_atom: received token env-find-str, length 12
       read_atom: returning sym 'env-find-str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ks)]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 661)
        tokenize: returning 'ks' (length 2)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')]
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 664)
        tokenize: returning ')' (length 1)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 665)
        tokenize: returning ']' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 666)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'if e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 672)
        tokenize: returning 'if' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' e
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 674)
        tokenize: returning 'e' (length 1)
       read_atom: received token if, length 2
       read_atom: returning sym 'if'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 676)
        tokenize: returning '(' (length 1)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'get @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 684)
        tokenize: returning 'get' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' @e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 687)
        tokenize: returning '@' (length 1)
       read_atom: received token get, length 3
       read_atom: returning sym 'get'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on 'e ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 689)
        tokenize: returning 'e' (length 1)
       read_atom: received token @, length 1
       read_atom: expanding deref
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ks)
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 690)
        tokenize: returning 'ks' (length 2)
       read_atom: received token e, length 1
       read_atom: returning sym 'e'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 693)
        tokenize: returning ')' (length 1)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
      (throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 694)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'throw (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 702)
        tokenize: returning 'throw' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 707)
        tokenize: returning '(' (length 1)
       read_atom: received token throw, length 5
       read_atom: returning sym 'throw'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 709)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "'" ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 712)
        tokenize: returning '"'"' (length 3)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ks "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 716)
        tokenize: returning 'ks' (length 2)
       read_atom: received token "'", length 3
       read_atom: before remove_escapes '''
       read_atom: returning str '''
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' "' not found"))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 719)
        tokenize: returning '"' not found"' (length 13)
       read_atom: received token ks, length 2
       read_atom: returning sym 'ks'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 733)
        tokenize: returning ')' (length 1)
       read_atom: received token "' not found", length 13
       read_atom: before remove_escapes '' not found'
       read_atom: returning str '' not found'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 734)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 735)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 736)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 737)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 738)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

(def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 739)
        tokenize: returning '(' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'def! env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 742)
        tokenize: returning 'def!' (length 4)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env-set (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 746)
        tokenize: returning 'env-set' (length 7)
       read_atom: received token def!, length 4
       read_atom: returning sym 'def!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 754)
        tokenize: returning '(' (length 1)
       read_atom: received token env-set, length 7
       read_atom: returning sym 'env-set'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'fn* [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 756)
        tokenize: returning 'fn*' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' [env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 759)
        tokenize: returning '[' (length 1)
       read_atom: received token fn*, length 3
       read_atom: returning sym 'fn*'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'env k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 761)
        tokenize: returning 'env' (length 3)
       read_atom: received token [, length 1
       read_atom: returning sym '['
   read_extended: vec
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 764)
        tokenize: returning 'k' (length 1)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' v]
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 766)
        tokenize: returning 'v' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ']
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 768)
        tokenize: returning ']' (length 1)
       read_atom: received token v, length 1
       read_atom: returning sym 'v'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
  (do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 769)
        tokenize: returning '(' (length 1)
       read_atom: received token ], length 1
       read_atom: returning sym ']'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'do
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 773)
        tokenize: returning 'do' (length 2)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    (swap! env assoc (str k) v)
    v)))

nil) ' (offset 775)
        tokenize: returning '(' (length 1)
       read_atom: received token do, length 2
       read_atom: returning sym 'do'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'swap! env assoc (str k) v)
    v)))

nil) ' (offset 781)
        tokenize: returning 'swap!' (length 5)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' env assoc (str k) v)
    v)))

nil) ' (offset 786)
        tokenize: returning 'env' (length 3)
       read_atom: received token swap!, length 5
       read_atom: returning sym 'swap!'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' assoc (str k) v)
    v)))

nil) ' (offset 790)
        tokenize: returning 'assoc' (length 5)
       read_atom: received token env, length 3
       read_atom: returning sym 'env'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' (str k) v)
    v)))

nil) ' (offset 796)
        tokenize: returning '(' (length 1)
       read_atom: received token assoc, length 5
       read_atom: returning sym 'assoc'
       read_form: starting read_extended
       read_atom: top of loop
        tokenize: called on 'str k) v)
    v)))

nil) ' (offset 798)
        tokenize: returning 'str' (length 3)
       read_atom: received token (, length 1
       read_atom: returning sym '('
   read_extended: list
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' k) v)
    v)))

nil) ' (offset 801)
        tokenize: returning 'k' (length 1)
       read_atom: received token str, length 3
       read_atom: returning sym 'str'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') v)
    v)))

nil) ' (offset 803)
        tokenize: returning ')' (length 1)
       read_atom: received token k, length 1
       read_atom: returning sym 'k'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' v)
    v)))

nil) ' (offset 804)
        tokenize: returning 'v' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')
    v)))

nil) ' (offset 806)
        tokenize: returning ')' (length 1)
       read_atom: received token v, length 1
       read_atom: returning sym 'v'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
    v)))

nil) ' (offset 807)
        tokenize: returning 'v' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')))

nil) ' (offset 813)
        tokenize: returning ')' (length 1)
       read_atom: received token v, length 1
       read_atom: returning sym 'v'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '))

nil) ' (offset 814)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ')

nil) ' (offset 815)
        tokenize: returning ')' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '

nil) ' (offset 816)
        tokenize: returning '' (length 1)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on '
nil) ' (offset 818)
        tokenize: returning 'nil' (length 3)
       read_atom: received token , length 1
       read_atom: returning sym ''
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ') ' (offset 822)
        tokenize: returning ')' (length 1)
       read_atom: received token nil, length 3
       read_atom: returning nil
       read_form: starting read_atom
       read_atom: top of loop
        tokenize: called on ' ' (offset 823)
        tokenize: found nothing (zero length token)
       read_atom: received token ), length 1
       read_atom: returning sym ')'
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: after args evaluated have (<function> (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (<function> (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
        mal_rest: called with (<function> (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil))
            eval: head of list to be applied <function>
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: rest of list to be applied ((do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
        mal_eval: called with ((do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: called with (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
environment: c000 (outer=core)
  "*ARGV*" -> ()
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
     macroexpand: called with (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
   is_macro_call: called with (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
         env_get: getting do
        env_find: finding do in 0x7fa723c1c000
          ht_has: called for key do
          ht_has: called for key do
         env_get: found 0x0
   is_macro_call: returning FALSE
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: macro expanded (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
        mal_rest: called with (do (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
do_special_form_before_continue:  ((def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))) (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))) (def! env-find (fn* [env k] (env-find-str env (str k)))) (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))) (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))) (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))  nil)
            eval: called with (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
   is_macro_call: called with (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
       mal_first: called with (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
       mal_first: called with (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
        mal_rest: called with (def! bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
def_special_form:  (bind-env (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))))
            eval: called with (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
     macroexpand: called with (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
   is_macro_call: called with (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
       mal_first: called with (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c1c000
          ht_has: called for key fn*
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
       mal_first: called with (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
        mal_rest: called with (fn* [env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
 fn_special_form:  ([env b e] (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e))))))
 fn_special_form: in fn* closure body is (if (empty? b) env (let* [b0 (first b)] (if (= (quote &) b0) (assoc env (str (nth b 1)) e) (bind-env (assoc env (str b0) (first e)) (rest b) (rest e)))))
         env_set: setting bind-env <function>
          ht_put: called for key bind-env
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: called with (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "bind-env" -> <function>
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
     macroexpand: called with (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
   is_macro_call: called with (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: macro expanded (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
        mal_rest: called with (def! new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
def_special_form:  (new-env (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: called with (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "bind-env" -> <function>
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
     macroexpand: called with (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
   is_macro_call: called with (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c1c000
          ht_has: called for key fn*
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
            eval: macro expanded (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
       mal_first: called with (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
        mal_rest: called with (fn* [& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
 fn_special_form:  ([& args] (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args)))))
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
         ht_keys: called on table with 1 entries
       ht_values: called on table with 1 entries
 fn_special_form: in fn* closure body is (if (<= (count args) 1) (atom {:outer (first args)}) (atom (apply bind-env {:outer (first args)} (rest args))))
         env_set: setting new-env <function>
          ht_put: called for key new-env
            eval: called with (def! env-find (fn* [env k] (env-find-str env (str k))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "bind-env" -> <function>
  "new-env" -> <function>
     macroexpand: called with (def! env-find (fn* [env k] (env-find-str env (str k))))
   is_macro_call: called with (def! env-find (fn* [env k] (env-find-str env (str k))))
       mal_first: called with (def! env-find (fn* [env k] (env-find-str env (str k))))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! env-find (fn* [env k] (env-find-str env (str k))))
       mal_first: called with (def! env-find (fn* [env k] (env-find-str env (str k))))
        mal_rest: called with (def! env-find (fn* [env k] (env-find-str env (str k))))
def_special_form:  (env-find (fn* [env k] (env-find-str env (str k))))
            eval: called with (fn* [env k] (env-find-str env (str k)))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "bind-env" -> <function>
  "new-env" -> <function>
     macroexpand: called with (fn* [env k] (env-find-str env (str k)))
   is_macro_call: called with (fn* [env k] (env-find-str env (str k)))
       mal_first: called with (fn* [env k] (env-find-str env (str k)))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c1c000
          ht_has: called for key fn*
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* [env k] (env-find-str env (str k)))
       mal_first: called with (fn* [env k] (env-find-str env (str k)))
        mal_rest: called with (fn* [env k] (env-find-str env (str k)))
 fn_special_form:  ([env k] (env-find-str env (str k)))
 fn_special_form: in fn* closure body is (env-find-str env (str k))
         env_set: setting env-find <function>
          ht_put: called for key env-find
            eval: called with (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "bind-env" -> <function>
  "env-find" -> <function>
  "new-env" -> <function>
     macroexpand: called with (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
   is_macro_call: called with (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
       mal_first: called with (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
       mal_first: called with (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
        mal_rest: called with (def! env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
def_special_form:  (env-find-str (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))))
            eval: called with (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "bind-env" -> <function>
  "env-find" -> <function>
  "new-env" -> <function>
     macroexpand: called with (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
   is_macro_call: called with (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
       mal_first: called with (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c1c000
          ht_has: called for key fn*
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
       mal_first: called with (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
        mal_rest: called with (fn* [env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
 fn_special_form:  ([env ks] (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks)))))
 fn_special_form: in fn* closure body is (if env (let* [data (deref env)] (if (contains? data ks) env (env-find-str (get data :outer) ks))))
         env_set: setting env-find-str <function>
          ht_put: called for key env-find-str
          ht_new: called for 10 entries
          ht_put: called for key *ARGV*
          ht_put: called for key bind-env
          ht_put: called for key env-find
          ht_put: called for key env-find-str
          ht_put: called for key new-env
            eval: called with (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "env-find-str" -> <function>
  "new-env" -> <function>
  "bind-env" -> <function>
  "env-find" -> <function>
     macroexpand: called with (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
   is_macro_call: called with (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
       mal_first: called with (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
       mal_first: called with (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
        mal_rest: called with (def! env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
def_special_form:  (env-get (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))))
            eval: called with (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
environment: c000 (outer=core)
  "*ARGV*" -> ()
  "env-find-str" -> <function>
  "new-env" -> <function>
  "bind-env" -> <function>
  "env-find" -> <function>
     macroexpand: called with (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
   is_macro_call: called with (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
       mal_first: called with (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c1c000
          ht_has: called for key fn*
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
       mal_first: called with (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
        mal_rest: called with (fn* [env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
 fn_special_form:  ([env k] (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found")))))
 fn_special_form: in fn* closure body is (let* [ks (str k) e (env-find-str env ks)] (if e (get (deref e) ks) (throw (str "'" ks "' not found"))))
         env_set: setting env-get <function>
          ht_put: called for key env-get
            eval: called with (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
environment: c000 (outer=core)
  "env-get" -> <function>
  "*ARGV*" -> ()
  "env-find-str" -> <function>
  "new-env" -> <function>
  "bind-env" -> <function>
  "env-find" -> <function>
     macroexpand: called with (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
   is_macro_call: called with (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
       mal_first: called with (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
         env_get: getting def!
        env_find: finding def! in 0x7fa723c1c000
          ht_has: called for key def!
          ht_has: called for key def!
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
       mal_first: called with (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
        mal_rest: called with (def! env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
def_special_form:  (env-set (fn* [env k v] (do (swap! env assoc (str k) v) v)))
            eval: called with (fn* [env k v] (do (swap! env assoc (str k) v) v))
environment: c000 (outer=core)
  "env-get" -> <function>
  "*ARGV*" -> ()
  "env-find-str" -> <function>
  "new-env" -> <function>
  "bind-env" -> <function>
  "env-find" -> <function>
     macroexpand: called with (fn* [env k v] (do (swap! env assoc (str k) v) v))
   is_macro_call: called with (fn* [env k v] (do (swap! env assoc (str k) v) v))
       mal_first: called with (fn* [env k v] (do (swap! env assoc (str k) v) v))
         env_get: getting fn*
        env_find: finding fn* in 0x7fa723c1c000
          ht_has: called for key fn*
          ht_has: called for key fn*
         env_get: found 0x0
   is_macro_call: returning FALSE
            eval: macro expanded (fn* [env k v] (do (swap! env assoc (str k) v) v))
       mal_first: called with (fn* [env k v] (do (swap! env assoc (str k) v) v))
        mal_rest: called with (fn* [env k v] (do (swap! env assoc (str k) v) v))
 fn_special_form:  ([env k v] (do (swap! env assoc (str k) v) v))
 fn_special_form: in fn* closure body is (do (swap! env assoc (str k) v) v)
         env_set: setting env-set <function>
          ht_put: called for key env-set
            eval: called with 
environment: c000 (outer=core)
  "env-get" -> <function>
  "*ARGV*" -> ()
  "env-find-str" -> <function>
  "env-set" -> <function>
  "new-env" -> <function>
  "bind-env" -> <function>
  "env-find" -> <function>
     macroexpand: called with 
   is_macro_call: called with 
            eval: macro expanded 
        eval_ast: called with 
         env_get: getting 
        env_find: finding  in 0x7fa723c1c000
          ht_has: called for key 
          ht_has: called for key 
         env_get: found 0x0
            eval: called with Exception: '' not found
            eval: called with Exception: '' not found
